#!/usr/bin/env perl
use strict;
use warnings;

use lib map { "$ENV{HOME}/sandbox/$_/lib" } qw(MIDI-Util Music-Cadence);
use Music::Cadence; # https://metacpan.org/release/Music-Cadence
use MIDI::Util; # https://metacpan.org/release/MIDI-Util
use Music::Chord::Note;

my $bpm = shift || 100;

my $score = MIDI::Util::setup_score( bpm => $bpm );

my $mc = Music::Cadence->new( octave => 4 );

my $cn = Music::Chord::Note->new;
my @chords = (
    $cn->chord('C'),
    $cn->chord('Dm'),
    $cn->chord('Em'),
    $cn->chord('F'),
    $cn->chord('G'),
    $cn->chord('Am'),
    $cn->chord('Bdim'),
);

my $whole = 'wn';

A();
A();

$score->n( $whole, @{ $chords[0] } );
$score->n( $whole, @{ $chords[0] } );

$score->write_score("$0.mid");

sub A {
    a1( 0, [1,2] );
    a1( 1, [4,2] );
    a2();
}

sub a1 {
    my ( $i, $degrees ) = @_;
    for my $n ( @$degrees ) {
        my $cadence = $mc->cadence(
            type    => 'half',
            leading => $n,
        );
        $score->n( $whole, @$_ ) for @$cadence;
    }
    if ( $i % 2 == 0 ) {
        $score->n( $whole, @{ $chords[2] } );
        $score->n( $whole, @{ $chords[5] } );
    }
    else {
        $score->n( $whole, @{ $chords[5] } );
        $score->n( $whole, @{ $chords[2] } );
    }
}

sub a2 {
    my $cadence = $mc->cadence(
        type      => 'imperfect',
        inversion => { 2 => 1 },
    );
    $score->n( $whole, @$_ ) for @$cadence;
    $score->n( $whole, @{ $chords[2] } );
    $score->n( $whole, @{ $chords[1] } );
}
