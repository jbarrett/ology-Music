#!/usr/bin/env perl
use strict;
use warnings;

use Algorithm::Evolutionary::Individual::BitString;
 
my $BITS    = shift || 11;  # Maximum pitches
my $DEGREES = shift || 7;   # Constraining scale

my $ae = Algorithm::Evolutionary::Individual::BitString->new($BITS);
print $ae->{_str}, "\n";

# Find a fit...
my $mutation = 0;
while ( not is_fit( $ae->{_str} ) )
{
    $mutation++;

    # Mutate!
    # Get a bit to twiddle
    my $n = int rand $BITS;
    warn "\t$mutation. N:$n\n";

    # Toggle the bit in the string
    $ae->Atom( $n, ($ae->Atom($n) ? 0 : 1) );
}

print $ae->{_str}, "\n";

my $pitches = bits2pitches( $ae->{_str} );
print '(', join( ',', @$pitches ), ')', "\n";

sub is_fit
{
    my $str = shift;

    my $is_fit = 0;

    # Count the number of zeros and ones
    my $zeros =()= $str =~ /0/g;
    my $ones  =()= $str =~ /1/g;
#    warn "Z,O:$zeros,$ones\n";
    # There should be more pitches (ones) than zeros
    $is_fit = $zeros < (2 * $BITS / 3) && $ones > ($BITS / 2)
        ? 1 : 0;
    return 0 unless $is_fit;

    # Include consonant pitches
    $is_fit = substr( $str, 0, 1 )
         && ( substr( $str, 0, 4 )  || substr( $str, 0, 5 )
           || substr( $str, 0, 7 )  || substr( $str, 0, 9 )  || substr( $str, 0, 11 )
           || substr( $str, 0, 12 ) || substr( $str, 0, 16 ) || substr( $str, 0, 17 )
           || substr( $str, 0, 19 ) || substr( $str, 0, 21 ) || substr( $str, 0, 23 ) )
        ? 1 : 0;
    return 0 unless $is_fit;

    # Do not allow clusters of more than two pitches
    $is_fit = $str =~ /1{3,}/ ? 0 : 1;

    return $is_fit;
}

sub bits2pitches
{
    # Convert 1001001000101000 form to [0,3,6,10,12] set form
    my $bitstring = shift;

    my $pitches = [];

    my $i = 0;
    for my $bit ( split //, $bitstring ) {
        push $pitches, $i % $DEGREES if $bit;
        $i++;
    }

    return $pitches;
}
