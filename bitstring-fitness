#!/usr/bin/env perl

=head1 NAME

bitstring-fitness - Bitstring mutation and pitch alteration

=head1 DESCRIPTION

TODO

=cut

use strict;
use warnings;

use Algorithm::Evolutionary::Individual::BitString;
use Getopt::Long;
use List::Util qw( shuffle );
use Music::AtonalUtil;
use MIDI::Simple;
 
my $BITS       = 11;  # Maximum pitches
my $DEGREES    = 7;   # Constraining scale
my $ALTERATION = 2;   # Post mutation phrase alteration factor
my $PHRASES    = 4;   # Number of times to play the "melody"
my $RHYTHM     = 0;   # Use rhythmic variations
my $MOTIF      = 4;   # Use a subset of the possible rhythms
my $TEMPO      = 600_000; # Miliseconds
my $PATCH      = 108; # The MID patch to use!
my $DIATONIC   = 0;   # use the diatonic notes, rather than chromatic
GetOptions (
    'bits=i'       => \$BITS,
    'degrees=i'    => \$DEGREES,
    'alteration=i' => \$ALTERATION,
    'phrases=i'    => \$PHRASES,
    'rhythm'       => \$RHYTHM,
    'motif=i'      => \$MOTIF,
    'tempo=i'      => \$TEMPO,
    'patch=i'      => \$PATCH,
    'diatonic'     => \$DIATONIC,
) or die("Error in command line arguments\n");

my $ae = Algorithm::Evolutionary::Individual::BitString->new($BITS);

# Show the initial mutation
print "Seed: $ae->{_str}\n";

mutate($ae);

# Show the final mutation
print "Final: $ae->{_str}\n";

# Turn the bitstring into a proper pitch set
my $pitches = bits2pitches( $ae->{_str} );

# Perform gymnastics with the pitches
my $altered = alteration($pitches);

# What have we now?
print '(', join( ',', @$pitches, @$altered ), ')', "\n";

process_midi( [ @$pitches, @$altered ] );

=head1 FUNCTIONS

=head2 process_midi()

=cut

sub process_midi
{
    my $pitches = shift;

    my %name  = int2name();
    my $score = set_score();

    # List possibe rhythmic durations
    my $durations = [qw(
        hn qn  en   sn
           dqn den  dsn
               dden ddsn
           tqn ten  tsn
    )];

    # Constrain durations but the number of motifs, if given
    my @motifs = ();
    if ($MOTIF)
    {
        # Rhythmic motif = DEGREES subset of durations
        @motifs = ( shuffle @$durations )[ 0 .. $MOTIF - 1 ];
    }

    # Play the number of phrases
    for my $phrase ( 1 .. $PHRASES )
    {
        # Given each pitch, decide on the duration to use
        for my $pitch ( @$pitches )
        {
            # If rhythmic variation is requested, draw from the duration list
            if ($RHYTHM)
            {
                my $duration;
                # Should we use a subset of the duration list?
                if ($MOTIF)
                {
                    $duration = ( @motifs )[ int rand @motifs ];
                }
                else {
                    $duration = ( @$durations )[ int rand @$durations ];
                }

                # Add the note to the score
                $score->n( $duration, $name{$pitch} );
            }
            # If rhythmic variation is not requested, use the given score unit
            else {
                $score->n( { $score->Cookies }->{unit}, $name{$pitch} );
            }
            $score->r( { $score->Cookies }->{unit} );
        }
    }

    $score->write_score( $0 . '.mid' );
}

=head2 mutate()

=cut

sub mutate
{
    my $species = shift;

    my $mutation = 0;
    # Find a fit...
    while ( not is_fit( $species->{_str} ) )
    {
        $mutation++;

        # Get a bit to twiddle
        my $n = int rand $BITS;
        warn "\t$mutation. N:$n\n";

        # Toggle the bit in the string
        $species->Atom( $n, ($species->Atom($n) ? 0 : 1) );
    }
}

=head2 alteration()

=cut

sub alteration
{
    my $pitches = shift;

    # Apply pitch set rules:
    @$pitches = shuffle( @$pitches );

    my $atu = Music::AtonalUtil->new;
    my $altered = $atu->transpose( 0, $pitches );

    # Post mutation, phrase alterations
    my $funct = {
        invert     => sub { my $x = shift; $atu->invert( $x, $altered ) },
        retrograde => sub { $atu->retrograde( @$pitches ) },
        rotate     => sub { my $x = shift; $atu->rotate( $x, $altered ) },
        transpose  => sub { my $x = shift; $atu->transpose( $x, $altered ) },
    };

    my $x = $ALTERATION;
    my $alteration = ( keys %$funct )[ rand keys %$funct ];
    print "Alteration: $alteration by $x\n";
    $altered = $funct->{$alteration}->($x);

    return $altered;
}

=head2 is_fit()

=cut

sub is_fit
{
    my $str = shift;

    my $is_fit = 0;

    # Count the number of zeros and ones
    my $zeros =()= $str =~ /0/g;
    my $ones  =()= $str =~ /1/g;
#    warn "Z,O:$zeros,$ones\n";
    # There should be more pitches (ones) than zeros
    $is_fit = $zeros < (2 * $BITS / 3) && $ones > ($BITS / 2)
        ? 1 : 0;
    return 0 unless $is_fit;

    # Include consonant pitches
#    $is_fit = substr( $str, 0, 1 ) ? 1 : 0;
    $is_fit = substr( $str, 0, 4 )  || substr( $str, 0, 5 )
           || substr( $str, 0, 7 )  || substr( $str, 0, 9 )  || substr( $str, 0, 11 )
           || substr( $str, 0, 12 ) || substr( $str, 0, 16 ) || substr( $str, 0, 17 )
           || substr( $str, 0, 19 ) || substr( $str, 0, 21 ) || substr( $str, 0, 23 )
        ? 1 : 0;
    return 0 unless $is_fit;

    # Do not allow clusters of more than two pitches
    $is_fit = $str =~ /1{3,}/ ? 0 : 1;

    return $is_fit;
}

=head2 bits2pitches()

=cut

sub bits2pitches
{
    # Convert 1001001000101000 form to [0,3,6,10,12] set form
    my $bitstring = shift;

    my $pitches = [];

    my $i = 0;
    for my $bit ( split //, $bitstring ) {
        push $pitches, $i % $DEGREES if $bit;
        $i++;
    }

    return $pitches;
}

=head2 int2name()

=cut

sub int2name
{
    # Convert integer pitch notation into MIDI note names
    my %name;
    my @notes;

    # Use the diatonic scale notes if requested
    if ($DIATONIC)
    {
        @notes = qw( C D E F G A B );
    }
    else {
        @notes = qw( C Cs D Ds E F G Gs A As B );
    }
    my $int = -( $BITS + 1 );
    for my $octave ( 3, 4, 5, 6 )
    {
        for my $note (@notes)
        {
            $name{ $int++ } = $note . $octave;
        }
    }
    return %name;
}

=head2 set_score()

=cut

sub set_score {
    my %conf = (
        tempo     => $TEMPO,
        volume    => 100,
        signature => 4,
        unit      => 'en',
        channel   => 1,
        patch     => $PATCH,
        octave    => 4,
        kit       => 9,
        pad       => 38,
    );

    my $score = MIDI::Simple->new_score();

    $score->Volume($conf{volume});
    $score->set_tempo($conf{tempo});

    # lead-in
#    $score->Channel($conf{kit});
#    $score->n($conf{unit}, $conf{pad}) for 1 .. $conf{signature};

    # passage
    $score->patch_change($conf{channel}, $conf{patch});
    $score->Channel($conf{channel});
    $score->Octave($conf{octave});
    $score->Cookies(unit => $conf{unit});

    return $score;
}

__END__
# Use 11 bits to mutate into a melody
# Use 2 for any Atonal::Util operation chosen
# Set tempo in milliseconds
# Use MIDI patch 1 (Acoustic Grand Piano)
# Use rhythmic variation
# Constrain the rhythmic variation to a subset
# Use the diatonic (as opposed to the chromatic) notes

> perl bitstring-fitness --bits=11 --alteration=2 --tempo=300_000 --patch=1 --rhythm --motif=4 --diatonic

