#!/usr/bin/env perl
use strict;
use warnings;

use Algorithm::Evolutionary::Individual::BitString;
 
my $max  = shift || 1;
my $bits = shift || 23;

my $ae = Algorithm::Evolutionary::Individual::BitString->new($bits);
print $ae->{_str}, "\n";

# Find a fit...
while ( not is_fit( $ae->{_str} ) )
{
    # Mutate!
    for my $i ( 1 .. $max )
    {
        # Get a bit to twiddle
        my $n = int rand $bits;
        warn "N:$n\n";

        # Toggle the bit in the string
        $ae->Atom( $n, ($ae->Atom($n) ? 0 : 1) );
    }
}

print $ae->{_str}, "\n";

sub is_fit
{
    my $str = shift;

    my $is_fit = 0;

    # Count the number of zeros and ones
    my $zeros =()= $str =~ /0/g;
    my $ones  =()= $str =~ /1/g;
    warn "V:$zeros,$ones\n";
    # There should be more pitches (ones) than zeros
    $is_fit = $zeros < (2 * $bits / 3) && $ones > ($bits / 2)
        ? 1 : 0;
    return 0 unless $is_fit;

    # Include consonant pitches
    $is_fit = substr( $str, 0, 1 )
         && ( substr( $str, 0, 4 )  || substr( $str, 0, 5 )
           || substr( $str, 0, 7 )  || substr( $str, 0, 9 )  || substr( $str, 0, 11 )
           || substr( $str, 0, 12 ) || substr( $str, 0, 16 ) || substr( $str, 0, 17 )
           || substr( $str, 0, 19 ) || substr( $str, 0, 21 ) || substr( $str, 0, 23 ) )
        ? 1 : 0;
    return 0 unless $is_fit;

    # Do not allow clusters of more than two pitches
    $is_fit = $str =~ /1{3,}/ ? 0 : 1;

    return $is_fit;
}
