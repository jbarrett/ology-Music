package MyPitch;
use Moo;
with 'Music::PitchNum';

package main;

# Use a circular list ("necklace") of Neo-Riemannian transformations,
# plus "X" meaning "make no transformation." Starting at position zero
# move forward or backward along the necklace, transforming the
# current chord, and render the resulting progression as MIDI.

use strict;
use warnings;

use Data::Dumper::Compact qw(ddc);
use Music::NeoRiemannianTonnetz ();
use Music::Chord::Note ();
use Music::Chord::Namer qw(chordname);
use lib map { "$ENV{HOME}/sandbox/$_/lib" } qw(MIDI-Util);
use MIDI::Util qw(setup_score midi_format);

my $max       = shift || 8;
my $bpm       = shift || 100;
my $note      = shift || 'G';
my $octave    = shift || '4';
my $transform = shift || 'X,PRL,R,L,R,L,R'; # Mostly diatonic
                                            # integer = random

if ($transform =~ /^\d+$/) {
    my @nro = qw(L P R N S H PRL);
    $transform = [ 'X', map { $nro[ int rand @nro ] } 2 .. $transform - 1 ];
}
else {
    $transform = [ split /,/, uc $transform ];
}

print "Initial: $note$octave\nTransforms: ", join(', ', @$transform), "\n";

my $nrt = Music::NeoRiemannianTonnetz->new;

my $cn = Music::Chord::Note->new;
my @chord = $cn->chord_with_octave($note, $octave);
my @base = get_base(@chord);

my $score = setup_score(bpm => $bpm);

my $p = MyPitch->new;
my @pitches = map { $p->pitchnum($_) } @chord;
my $notes = \@pitches;

my $posn = 0;

for my $i (1 .. $max) {
    my $token = $transform->[ $posn % @$transform ];

    my $transformed;
    if ($token =~ /^X$/) {
        $transformed = \@pitches; # no transformation
    }
    else {
        my $task = $nrt->taskify_tokens($token) if length $token > 1;
        my $tx = defined $task ? $task : $token;
        $transformed = $nrt->transform($tx, $notes);
    }

    $score->n('wn', midi_format(@$transformed));

    @chord = map { $p->pitchname($_) } @$transformed;
    @base = get_base(@chord);

    printf "%d. %s (%d): %s   %s   %s\n",
        $i, $token, $posn % @$transform,
        ddc($transformed), ddc(\@chord),
        scalar chordname(@base);

    $notes = $transformed;

    $posn = int rand 2 ? $posn + 1 : $posn - 1;
}

$score->write_score("$0.mid");

sub get_base {
    my (@chord) = @_;
    my @base = map { s/^([A-G][#b]?)\d/$1/r } @chord;
    return @base;
};
