#!/usr/bin/env perl
use strict;
use warnings;

# Use local libraries
use lib map { "$ENV{HOME}/sandbox/$_/lib" } qw( MIDI-Drummer-Tiny MIDI-Util Music-Duration Music-Duration-Partition );

use MIDI::Drummer::Tiny;
use MIDI::Util qw(set_chan_patch);
use Music::CreatingRhythms ();
use Music::Duration::Partition;
use Music::Scales;
use Music::VoiceGen;

my $bpm   = shift || 90;
my $patch = shift // 35;#42; # bass patch : -1 = off
my $note  = shift || 'A';
my $scale = shift || 'pminor';

my $phrase_size = 16; # changing this will possibly make the bass have a bad day

my $kick_onset_B = rand_onset();
while ($kick_onset_B < 3) {
    $kick_onset_B = rand_onset();
}
my $snare_onset_B = rand_onset();
while ($snare_onset_B >= $kick_onset_B) {
    $snare_onset_B = rand_onset();
}
my $kick_onset_A = rand_onset();
while ($kick_onset_A < 3) {
    $kick_onset_A = rand_onset();
}
my $snare_onset_A = rand_onset();
while ($snare_onset_A >= $kick_onset_B) {
    $snare_onset_A = rand_onset();
}

my $d = MIDI::Drummer::Tiny->new(
    file    => "$0.mid",
    bpm     => $bpm,
    verbose => 1,
);

$d->count_in(1);

part($snare_onset_A, $kick_onset_A);
#counterpart();
part($snare_onset_A, $kick_onset_A);
#counterpart();
part($snare_onset_B, $kick_onset_B);
#counterpart();
part($snare_onset_B, $kick_onset_B);

$d->write;

sub rand_onset {
    my ($n) = @_;
    $n ||= 8;
    return 1 + int rand $n;
}

sub counterpart {
    set_chan_patch($d->score, 9, 0);
    $d->count_in($d->bars);
}

sub rotate_sequence {
    my ($onsets) = @_;
    my $mcr = Music::CreatingRhythms->new;
    my $sequence = $mcr->euclid($onsets, $phrase_size);
    $sequence = $mcr->rotate_n(2, $sequence);
    my $sequence_string = join '', @$sequence;
    return $sequence_string;
}

sub part {
    my ($snare_ons, $kick_ons) = @_;
    set_chan_patch($d->score, 9, 0);
    my $hh = '1' x ($phrase_size / 2);
    $d->sync(
        sub { $d->pattern( instrument => $d->closed_hh, patterns => [ ($hh) x ($d->bars - 1) ] ) },
        sub { $d->pattern( instrument => $d->snare,     patterns => [ (rotate_sequence($snare_ons)) x ($d->bars - 1) ] ) },
        sub { $d->pattern( instrument => $d->kick,      patterns => [ ($d->euclidean($kick_ons, $phrase_size)) x ($d->bars - 1) ] ) },
        sub { bottom($d->bars - 1) },
    );
    $d->sync(
        sub { fill($snare_ons, $kick_ons) },
        sub { bottom(1) },
    );
}

sub fill {
    my ($snare_onset, $kick_onset) = @_;
    set_chan_patch($d->score, 9, 0);
    my $hh = '1' x ($phrase_size / 2);
    $d->add_fill(
        sub {
            my $self = shift;
            my $snare_ons = 1 + int rand($phrase_size / 2);
            my $f_hh = '0' x ($phrase_size / 2);
            (my $f_kick = $f_hh) =~ s/^0/1/;
            return {
                duration         => $phrase_size,
                $self->closed_hh => $f_hh,
                $self->snare     => $d->euclidean($snare_ons, $phrase_size / 2),
                $self->kick      => $f_kick,
            };
        },
        $d->closed_hh => [ $hh ],
        $d->snare     => [ rotate_sequence($snare_onset) ],
        $d->kick      => [ $d->euclidean($kick_onset, $phrase_size) ],
    );
}

sub bottom {
    my ($bars) = @_;

    return if $patch < 0;

    $bars ||= $d->bars;

    set_chan_patch($d->score, 1, $patch);

    my $size = $phrase_size / 4 - 1; # number of beats to play over

    my $mdp1 = Music::Duration::Partition->new(
        size => $size,
        pool => [qw/qn en sn/],
        #verbose=>1,
    );
    my $motif1 = $mdp1->motif;

    my $mdp2 = Music::Duration::Partition->new(
        size => $size,
        pool => [qw/qn en/],
        #verbose=>1,
    );
    my $motif2 = $mdp2->motif;

    my @pitches = get_scale_MIDI($note, 1, $scale);

    my $voice = Music::VoiceGen->new(
        pitches   => \@pitches,
        intervals => [qw/-4 -3 -2 2 3 4/],
    );

    my @notes1 = map { $voice->rand } @$motif1;

    for my $i (1 .. $bars) {
        if ($i % 2) {
            $mdp1->add_to_score($d->score, $motif1, \@notes1);
        }
        else {
            my @notes2 = map { $voice->rand } @$motif2;
            $mdp2->add_to_score($d->score, $motif2, \@notes2);
        }

        $d->rest($d->quarter);
    }
}
