#!/usr/bin/env perl

# Usage: perl figured-syncopation --options
# Examples:
# perl figured-syncopation # just go with the defaults
# perl figured-syncopation --bpm=200 # speed it up
# perl figured-syncopation --patch=35 # make up a bassline
# perl figured-syncopation --akick=2 --asnare=3 --bkick=5 --bsnare=3
# perl figured-syncopation --ak=2 --as=3 --bk=3 --bs=2 # abbreviate

use strict;
use warnings;

# use my local author libraries
use lib map { "$ENV{HOME}/sandbox/$_/lib" } qw(MIDI-Drummer-Tiny MIDI-Util Music-CreatingRhythms Music-Duration Music-Duration-Partition);

use Getopt::Long qw(GetOptions);
use MIDI::Drummer::Tiny ();
use MIDI::Util qw(set_chan_patch);
use Music::CreatingRhythms ();
use Music::Duration::Partition ();
use Music::Scales qw(get_scale_MIDI);
use Music::VoiceGen ();

my %opts = (
    bpm         => 90, # beats per minute
    phrase_size => 16, # changing this will probably make the bass player have a bad day
    akick       => 0,  # set by user or init below
    asnare      => 0,  # "
    bkick       => 0,  # "
    bsnare      => 0,  # "
    patch       => -1,       # 0 or 35 or 42, etc. Bass patch : -1 = off
    note        => 'A',      # bass scale starting note
    scale       => 'pminor', # bass scale name
);
GetOptions(\%opts,
    'bpm=i',
    'phrase_size=i',
    'akick=i',
    'asnare=i',
    'bkick=i',
    'bsnare=i',
    'patch=i',
    'note=s',
    'scale=s',
) or die("Error in command line arguments\n");

# initialize the kick and snare onsets
my $kick_onset_B = $opts{bkick};
unless ($kick_onset_B) {
    $kick_onset_B = rand_onset();
    while ($kick_onset_B < 3) {
        $kick_onset_B = rand_onset();
    }
}
my $snare_onset_B = $opts{bsnare};
unless ($snare_onset_B) {
    $snare_onset_B = rand_onset();
    while ($snare_onset_B >= $kick_onset_B) {
        $snare_onset_B = rand_onset();
    }
}
my $kick_onset_A = $opts{akick};
unless ($kick_onset_A) {
    $kick_onset_A = rand_onset();
    while ($kick_onset_A < 3) {
        $kick_onset_A = rand_onset();
    }
}
my $snare_onset_A = $opts{asnare};
unless ($snare_onset_A) {
    $snare_onset_A = rand_onset();
    while ($snare_onset_A >= $kick_onset_B) {
        $snare_onset_A = rand_onset();
    }
}
print "Snare A onset = $snare_onset_A, Kick A onset = $kick_onset_A\n";
print "Snare B onset = $snare_onset_B, Kick B onset = $kick_onset_B\n";

my $d = MIDI::Drummer::Tiny->new(
    file    => "$0.mid",
    bpm     => $opts{bpm},
    #verbose => 1,
);

$d->count_in(1);

part($snare_onset_A, $kick_onset_A);
#counterpart();
part($snare_onset_A, $kick_onset_A);
#counterpart();
part($snare_onset_B, $kick_onset_B);
#counterpart();
part($snare_onset_B, $kick_onset_B);

$d->write;

sub rand_onset {
    my ($n) = @_;
    $n ||= 8;
    return 1 + int rand $n;
}

sub counterpart {
    set_chan_patch($d->score, 9, 0);
    $d->count_in($d->bars);
}

sub rotate_sequence {
    my ($onsets) = @_;
    my $mcr = Music::CreatingRhythms->new;
    my $sequence = $mcr->euclid($onsets, $opts{phrase_size});
    $sequence = $mcr->rotate_n(2, $sequence);
    my $sequence_string = join '', @$sequence;
    return $sequence_string;
}

sub part {
    my ($snare_ons, $kick_ons) = @_;
    set_chan_patch($d->score, 9, 0);
    my $hh = '1' x ($opts{phrase_size} / 2);
    $d->sync(
        sub { $d->pattern( instrument => $d->closed_hh, patterns => [ ($hh) x ($d->bars - 1) ] ) },
        sub { $d->pattern( instrument => $d->snare,     patterns => [ (rotate_sequence($snare_ons)) x ($d->bars - 1) ] ) },
        sub { $d->pattern( instrument => $d->kick,      patterns => [ ($d->euclidean($kick_ons, $opts{phrase_size})) x ($d->bars - 1) ] ) },
        sub { bottom($d->bars - 1) },
    );
    $d->sync(
        sub { fill($snare_ons, $kick_ons) },
        sub { bottom(1) },
    );
}

sub fill {
    my ($snare_onset, $kick_onset) = @_;
    set_chan_patch($d->score, 9, 0);
    my $hh = '1' x ($opts{phrase_size} / 2);
    $d->add_fill(
        \&_fill,
        $d->closed_hh => [ $hh ],
        $d->snare     => [ rotate_sequence($snare_onset) ],
        $d->kick      => [ $d->euclidean($kick_onset, $opts{phrase_size}) ],
    );
}

sub _fill {
    my ($self) = @_;
    my $snare_ons = 1 + int rand($opts{phrase_size} / 2);
    my $hh = '0' x ($opts{phrase_size} / 2);
    (my $kick = $hh) =~ s/^0/1/;
    return {
        duration         => $opts{phrase_size},
        $self->closed_hh => $hh,
        $self->snare     => $d->euclidean($snare_ons, $opts{phrase_size} / 2),
        $self->kick      => $kick,
    };
}

sub bottom {
    my ($bars) = @_;

    return if $opts{patch} < 0;

    $bars ||= $d->bars;

    set_chan_patch($d->score, 1, $opts{patch});

    my $size = $opts{phrase_size} / 4 - 1; # number of beats to play over

    my $mdp1 = Music::Duration::Partition->new(
        size => $size,
        pool => [qw/qn en sn/],
        #verbose=>1,
    );
    my $motif1 = $mdp1->motif;

    my $mdp2 = Music::Duration::Partition->new(
        size => $size,
        pool => [qw/qn en/],
        #verbose=>1,
    );
    my $motif2 = $mdp2->motif;

    my @pitches = get_scale_MIDI($opts{note}, 1, $opts{scale});

    my $voice = Music::VoiceGen->new(
        pitches   => \@pitches,
        intervals => [qw/-4 -3 -2 2 3 4/],
    );

    my @notes1 = map { $voice->rand } @$motif1;

    for my $i (1 .. $bars) {
        if ($i % 2) {
            $mdp1->add_to_score($d->score, $motif1, \@notes1);
        }
        else {
            my @notes2 = map { $voice->rand } @$motif2;
            $mdp2->add_to_score($d->score, $motif2, \@notes2);
        }

        $d->rest($d->quarter);
    }
}
