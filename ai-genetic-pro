#!/usr/bin/env perl

use AI::Genetic::Pro;
use Music::PitchNum;
use MIDI::Simple;
use Music::AtonalUtil;

#my @notes = 60 .. 71; # chromatic
my @notes = qw( 60 62 64 65 67 69 71 ); # diatonic in C

my $ga = AI::Genetic::Pro->new(        
        -fitness         => \&fitness,        # fitness function
        -terminate       => \&terminate,      # terminate function
        -type            => 'combination',    # type of chromosomes
        -population      => 100,              # population
        -crossover       => 0.9,              # probab. of crossover
        -mutation        => 0.05,             # probab. of mutation
        -parents         => 2,                # number  of parents
        -selection       => [ 'Roulette' ],   # selection strategy
        -strategy        => [ 'PMX' ],        # crossover strategy
        -cache           => 1,                # cache results
        -history         => 1,                # remember best results
        -preserve        => 1,                # remember the bests
        -variable_length => 0,                # turn variable length OFF
);

$ga->init( \@notes );

$ga->evolve(1000);

# Perform gymnastics with the pitches
my $pitches = $ga->as_array($ga->getFittest);
my $alt = [ map { $_ + 60 } @{ alteration( [ map { $_ - 60 } @$pitches ] ) } ];
$pitches = [ map { Music::PitchNum->pitchname($_) } @$pitches, @$alt ];
for ( @$pitches, @$alt )
{
    $_ =~ s/^([A-Z])(\d)$/$1$2/;
    $_ =~ s/^(\w)\#(\d)$/$1s$2/;
}
use Data::Dumper::Concise;warn Dumper$pitches;
warn $ga->as_value($ga->getFittest), "\n";

process_midi($pitches);

sub calc {
    my ($ar) = @_;
#warn(__PACKAGE__,' ',__LINE__," MARK: @$ar\n");
    my $calc = 0;
    # Adjacent elements must be within ...
    for my $n ( 0 .. @$ar - 2 ) {
        my $v = abs( $ar->[$n] - $ar->[$n + 1] );
        $calc++ if $v >= 2 && $v <= 5;
    }
#warn "\t = $calc\n";
    return $calc;
}

sub fitness {
    my ($ga, $chromosome) = @_;
    return calc(scalar $ga->as_array($chromosome));
}

sub terminate {
    my ($ga) = @_;
    return 1 if $ga->as_value($ga->getFittest) >= 1;
    return;
}

sub set_score {
    my %conf = (
        tempo     => 600_000,
        volume    => 100,
        velocity  => 96,
        unit      => 'qn',
        channel   => 1,
        patch     => 1,
    );

    my $score = MIDI::Simple->new_score();

    $score->set_tempo($conf{tempo});
    $score->noop('V' . $conf{volume}, 'c' . $conf{channel});
    $score->patch_change($conf{channel}, $conf{patch});

    $score->Cookies(unit => $conf{unit});
    $score->Cookies(velocity => $conf{velocity});

    return $score;
}

sub process_midi
{
    my ( $pitches ) = @_;
    my $score = set_score();
    for my $p ( @$pitches )
    {
        $score->n( { $score->Cookies }->{unit}, $p, { $score->Cookies }->{velocity} );
    }
    $score->write_score( $0 . '.mid' );
}

sub alteration {
    my $pitches = shift;

    my $atu = Music::AtonalUtil->new;

    # Post mutation, phrase alterations
    my $funct = {
        invert     => sub { my $x = shift; $atu->invert( $x, $pitches ) },
        retrograde => sub { $atu->retrograde( @$pitches ) },
        rotate     => sub { my $x = shift; $atu->rotate( $x, $pitches ) },
        transpose  => sub { my $x = shift; $atu->transpose( $x, $pitches ) },
    };

    # Choose a random function and execute it with the given alteration factor
    my $x = int( rand 3 ) + 2;
    my $alteration = ( keys %$funct )[ rand keys %$funct ];
    print "Alteration: $alteration by $x\n";
    my $altered = $funct->{$alteration}->($x);

    return $altered;
}
