#!/usr/bin/env perl
use strict;
use warnings;

use Algorithm::Combinatorics qw( variations );
use List::Util qw( shuffle );
use lib '/Users/gene/sandbox/MIDI-Util/lib';
use MIDI::Util;
 
my $treb  = shift || '0 C5 E5 G5'; # 0 = rest
my $bass  = shift || 'C4 F4 G4'; # Notes only - no rests
my $bpm   = shift || 120;
my $trebp = shift || 69; # Treble patch
my $bassp = shift || 42; # Bass patch

my @treb = split / /, $treb;
my @bass = split / /, $bass;

my $size = 0; # Number of score events

my $score = MIDI::Util::setup_midi( bpm => $bpm );

$score->synch(
    \&variance,
    \&legato,
);

$score->n( 'wn', $bass[0] );
$score->write_score( "$0.mid" );

sub variance {
    MIDI::Util::set_chan_patch( $score, 0, $trebp );

    my $count = 1;

    for my $n ( 1 .. @treb ) {
        my @items = shuffle variations( \@treb, $n );

        for my $i (@items) {
            print "$count. @$i\n";
            $count++;

            for my $note ( @$i ) {
                if ( $note eq '0' ) {
                    $score->r('qn');
                }
                else {
                    $score->n( 'qn', $note );
                }

                $size++;
            }
        }
    }
}

sub legato {
    MIDI::Util::set_chan_patch( $score, 1, $bassp );
    $score->Volume(60);

    $score->n( 'wn', $bass[ int rand @bass ] )
        for 1 .. $size / 4;
}
