#!/usr/bin/env perl
use strict;
use warnings;

use MIDIUtil; # Found in the same github directory...
use Music::Note;
use Music::Scales;

my $rule       = shift || 2,
my $iterations = shift || 4;
my $string     = shift || 'F';
my $chromatic  = shift // 1;
my $distance   = shift || 'qn';
my $theta      = shift || 1;

my %rules = (
    # Branches: start=X
    1 => {
        X => 'YF-X+X',
        Y => 'F',
    },

    # Koch curve: start=F
    2 => {
        F => 'F+F-F-F+F',
    },

    # Fractal plant: start=X
    3 => {
        X => 'F-XXF-X+FX',
        F => 'FF',
    },

    # Dragon curve: start=FX
    4 => {
        X => 'X+YF+',
        Y => '-FX-Y',
    },

    # Sierpiński arrowhead curve: start=F
    5 => {
        F => 'G-F-G',
        G => 'F+G+F',
    },

    # Sierpiński triangle: start=F-G-G
    6 => {
        F => 'F-G+F+G-F',
        G => 'GG',
    },

    # Koch snowflake: start=F++F++F
    7 => {
        F => 'F-F++F-F',
        X => 'FF',
    },

    # Sierpiński carpet: start=F
    8 => {
        F => 'F+F-F-F-G+F+F+F-F',
        G => 'GGG',
    },

    # Koch island: start=F-F-F-F
    9 => {
        F => 'F-F+F+FF-F-F+F',
    },

    # Koch islands and lakes: start=F+F+F+F
    10 => {
        F => 'F+f-FF+F+FF+Ff+FF-f+FF-F-FF-Ff-FFF',
        f => 'ffffff',
    },

    # Grid: start=F-F-F-F
    11 => {
        F => 'FF-F-F-F-FF',
    },

    # Terndrils: start=F-F-F-F
    12 => {
        F => 'FF-F--F-F',
    },
);

my $score = MIDIUtil::setup_midi( patch => 0, bpm => 300 );

my $note = 60;

my %translate = (
    'f' => sub { $score->r($distance) },
    'F' => sub { $score->n( $distance, $note ) },
    'G' => sub { $score->n( $distance, $note ) },
    '-' => sub { $note = $chromatic ? $note + $theta : offset( $note, $theta ) },
    '+' => sub { $note = $chromatic ? $note - $theta : offset( $note, - $theta ) },
);

for ( 1 .. $iterations ) {
    $string =~ s/(.)/defined($rules{$rule}{$1}) ? $rules{$rule}{$1} : $1/eg;
}
warn "$string\n";

for my $command ( split //, $string ) {
    $translate{$command}->() if exists $translate{$command};
}

$score->write_score( $0 . '.mid' );

sub offset {
    my ( $notenum, $offset ) = @_;

    my @scale = get_scale_notes('C');

    my $note = Music::Note->new( $notenum, 'midinum' );

    my $base = $note->format('isobase');

    ( my $octave = $note->format('ISO') ) =~ s/^[A-G](\d)$/$1/;

    my $new;

    my $i = 0;

    for my $item ( @scale ) {
        if ( $scale[$i] eq $base ) {
            if ( $i + $offset < 0 ) {
                $octave--;
            }
            $new = $scale[ ( $i + $offset ) % @scale ] . $octave;
            last;
        }
        $i++;
    }

    $note = Music::Note->new( $new, 'ISO' );

    return $note->format('midinum');
}
