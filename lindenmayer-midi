#!/usr/bin/env perl
use strict;
use warnings;

use MIDIUtil; # Found in the same github directory...
use lib '/Users/gene/sandbox/Music-ScaleNote/lib';
use Music::ScaleNote;
use Music::Note;
use Music::Scales;

my $rule       = shift || 2,
my $iterations = shift || 4;
my $duration   = shift || 'qn';
my $offset     = shift || 1;
my $scale      = shift || 'major';
my $midi_note  = shift || 60;
my $bpm        = shift || 300;

$duration = [ split /\s+/, $duration ];

my $format = 'midinum';
my $patchf = 0;
my $patchg = 13;

my %rules = (
    # Branches
    1 => {
        axiom => 'X',
        X => 'YF-X+X',
        Y => 'F',
    },

    # Koch curve
    2 => {
        axiom => 'F',
        F => 'F+F-F-F+F',
    },

    # Fractal plant
    3 => {
        axiom => 'X',
        X => 'F-XXF-X+FX',
        F => 'FF',
    },

    # Dragon curve
    4 => {
        axiom => 'FX',
        X => 'X+YF+',
        Y => '-FX-Y',
    },

    # Sierpiński arrowhead curve
    5 => {
        axiom => 'F',
        F => 'G-F-G',
        G => 'F+G+F',
    },

    # Sierpiński triangle
    6 => {
        axiom => 'F-G-G',
        F => 'F-G+F+G-F',
        G => 'GG',
    },

    # Koch snowflake
    7 => {
        axiom => 'F++F++F',
        F => 'F-F++F-F',
        X => 'FF',
    },

    # Sierpiński carpet
    8 => {
        axiom => 'F',
        F => 'F+F-F-F-G+F+F+F-F',
        G => 'GGG',
    },

    # Koch island
    9 => {
        axiom => 'F-F-F-F',
        F => 'F-F+F+FF-F-F+F',
    },

    # Koch islands and lakes
    10 => {
        axiom => 'F+F+F+F',
        F => 'F+f-FF+F+FF+Ff+FF-f+FF-F-FF-Ff-FFF',
        f => 'ffffff',
    },

    # Grid
    11 => {
        axiom => 'F-F-F-F',
        F => 'FF-F-F-F-FF',
    },

    # Terndrils
    12 => {
        axiom => 'F-F-F-F',
        F => 'FF-F--F-F',
    },
);

my $string = $rules{$rule}{axiom};

my $score = MIDIUtil::setup_midi( bpm => $bpm );

my $note = Music::Note->new( $midi_note, $format );

my $msn = Music::ScaleNote->new(
    scale_note => $note->format('isobase'),
    scale_name => $scale,
);

my %translate = (
    'f' => sub { $score->r( random_duration( @$duration ) ) },
    'F' => sub {
        MIDIUtil::set_chan_patch( $score, 0, $patchf );
        $score->n( random_duration( @$duration ), $midi_note );
    },
    'G' => sub {
        MIDIUtil::set_chan_patch( $score, 0, $patchg );
        $score->n( random_duration( @$duration ), $midi_note );
    },
    '-' => sub {
        $midi_note = $msn->get_offset(
            note_name   => $midi_note,
            note_format => $format,
            offset      => $offset,
        )->format($format);
    },
    '+' => sub {
        $midi_note = $msn->get_offset(
            note_name   => $midi_note,
            note_format => $format,
            offset      => -$offset,
        )->format($format);
    },
);

for ( 1 .. $iterations ) {
    $string =~ s/(.)/defined($rules{$rule}{$1}) ? $rules{$rule}{$1} : $1/eg;
}
warn "$string\n";

for my $command ( split //, $string ) {
    $translate{$command}->() if exists $translate{$command};
}

$score->write_score( $0 . '.mid' );

sub random_duration {
    my (@duration) = @_;
    return $duration[ int rand @duration ];
}
