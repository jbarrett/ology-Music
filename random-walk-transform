#!/usr/bin/env perl
use strict;
use warnings;

use Graph::Weighted;
use List::Util::WeightedChoice qw( choose_weighted );
use MIDI::Simple;
use Music::AtonalUtil;
use Readonly;

Readonly my $MIDDLE_C => 60;
Readonly my $RANDOM_PARAMETER => 6;
Readonly my $RANDOM_TRANSFORM => 3;

my $max       = shift || 4; # Number of notes
my $initial   = shift // 0; # Initial graph node
my $transform = shift // 0; # 0=invert, 1=retrograde, 2=rotate. -1=random
my $param     = shift // 0; # Used for invert & rotate, -1=random
my $repeat    = shift // 0; # For reapplication of transformation

my $treble = Graph::Weighted->new();
$treble->populate(
    {
        0 => { label => 60, 2 => 0.4, 6 => 0.6 },
        1 => { label => 62, 3 => 0.4, 4 => 0.6 },
        2 => { label => 63, 1 => 0.5, 3 => 0.5 },
        3 => { label => 65, 5 => 0.4, 4 => 0.6 },
        4 => { label => 67, 2 => 0.4, 3 => 0.6 },
        5 => { label => 68, 4 => 0.4, 6 => 0.6 },
        6 => { label => 70, 0 => 0.4, 3 => 0.6 },
    }
);
my $bass = Graph::Weighted->new();
$bass->populate(
    {
        0 => { label => 36, 2 => 0.4, 3 => 0.6 },
        1 => { label => 39, 2 => 0.5, 3 => 0.5 },
        2 => { label => 41, 0 => 0.4, 3 => 0.6 },
        3 => { label => 43, 4 => 0.4, 2 => 0.6 },
        4 => { label => 46, 0 => 0.4, 1 => 0.6 },
    }
);
my $duration = Graph::Weighted->new();
$duration->populate(
    {
        0 => { label => 'qn', 0 => 0.7, 1 => 0.3 },
        1 => { label => 'en', 0 => 0.6, 1 => 0.4 },
    }
);
my $velocity = Graph::Weighted->new();
$velocity->populate(
    {
        0 => { label => 'mezzo', 0 => 0.7, 1 => 0.3 },
        1 => { label => 'mf',    0 => 0.6, 1 => 0.4 },
    }
);

my $notes = collect_notes( $max, $initial, $velocity, $duration, $treble, $bass );

for ( 1 .. $repeat ) {
    $notes = transform_treble( $notes, $transform, $param );
}

score_midi( notes => $notes );

sub score_midi {
    my %args = (
        notes   => [],
        lead_in => 4,
        channel => 1,
        patch   => 42,
        volume  => 120,
        @_,
    );
    my $score = MIDI::Simple->new_score();
    $score->Volume($args{volume});
    # Lead-in
    $score->Channel(9);
    $score->n( 'qn', $args{patch} ) for 1 .. $args{lead_in};
    # Passage
    $score->Channel($args{channel});
    $score->patch_change( $args{channel}, $args{patch} );
    # Add notes to the score
    $score->n( @$_ ) for @{ $args{notes} };
    # Write out the score
    $score->write_score( $0 . '.mid' );
}

sub next_vertex {
    my ( $g, $vertex ) = @_;

    my $successors = [];

    for my $successor ( $g->successors($vertex) ) {
        push @$successors, {
            vertex => $successor,
            weight => $g->get_cost( [ $vertex, $successor ] ),
        };
    }

    my $choice = choose_weighted( $successors, sub { $_[0]->{weight} } );

    return $choice->{vertex};
}

sub collect_notes {
    my ( $max, $initial, $velocity, $duration, $treble, $bass ) = @_;

    my ( $t_vertex, $b_vertex, $d_vertex, $v_vertex ) = ($initial) x 4;

    my $notes = [];

    for my $i ( 1 .. $max ) {
        my $treb = $treble->get_vertex_attribute( $t_vertex, 'label' );
        my $low  = $bass->get_vertex_attribute( $b_vertex, 'label' );
        my $dura = $duration->get_vertex_attribute( $d_vertex, 'label' );
        my $velo = $velocity->get_vertex_attribute( $v_vertex, 'label' );

        push @$notes, [ $velo, $dura, $treb, $low ];

        if ( $i < $max ) {
            $t_vertex = next_vertex( $treble, $t_vertex );
            $b_vertex = next_vertex( $bass, $b_vertex );
            $d_vertex = next_vertex( $duration, $d_vertex );
            $v_vertex = next_vertex( $velocity, $v_vertex );
        }
    }

    return $notes;
}

sub transform_treble {
    my ( $phrase, $transform, $param ) = @_;

    my $pitches = [ map { $_->[2] - $MIDDLE_C } @$phrase ];

    my $mau = Music::AtonalUtil->new;

    my $new;

    if ( $param == -1 ) {
        $param = int rand $RANDOM_PARAMETER;
    }

    if ( $transform == -1 ) {
        $transform = int rand $RANDOM_TRANSFORM;
    }

    if ( $transform == 0 ) {
        print "Transform: invert $param\n";
        $new = $mau->invert( $param, $pitches );
    }
    elsif ( $transform == 1 ) {
        print "Transform: retrograde\n";
        $new = $mau->retrograde($pitches);
    }
    elsif ( $transform == 2 ) {
        print "Transform: rotate $param\n";
        $new = $mau->rotate( $param, $pitches );
    }

    my $tansformed = [
        map {
            [ $phrase->[$_][0], $phrase->[$_][1], $MIDDLE_C + $new->[$_], $phrase->[$_][3] ]
        } 0 .. @$phrase - 1
    ];

    $phrase = [ @$phrase, @$tansformed ];

    return $phrase;
}
