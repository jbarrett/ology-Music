#!/usr/bin/env perl

# Ex:
# $ perl drum-circle 11; timidity -c ~/timidity.cfg drum-circle.mid

use strict;
use warnings;

# Use my local libraries
use lib map { "$ENV{HOME}/sandbox/$_/lib" } qw(MIDI-Drummer-Tiny MIDI-Util Music-Duration Music-Duration-Partition);

use MIDI::Drummer::Tiny;
use Music::Duration::Partition;
use Data::Dumper::Compact qw(ddc);

#use Pod::Usage qw(pod2usage);
#pod2usage(-verbose => 2); exit;
# perl drum-circle > ~/Documents/drum-circle.txt

=head1 DESCRIPTION

Ever heard tribal drumming coming from your local park?

Getting closer will reveal a circle of random people playing
percussion instruments. Some with bongos, maybe congas, shakers and
rattles, djembes, etc, etc.

This is a "drum circle", which may include friendly hippies.

And speaking of... How do you know if any hippies have been in your
house?

Ok ok. As with other things in my Github Music repo, I decided to
simulate this organic phenomenon with Perl.

=head1 THE CODE

=head2 Setup

1. Set the user defined number of drummers to play. This is 4 by
default and 11 max.

2. Set the user defined number of measures to play after all drummers
have joined the circle. This is 4 by default.

3. Declare a L<MIDI::Drummer::Tiny> instance, that will be the beating
heart of the program.

4. Declare the known percussion instruments. These are:

  hi_bongo
  low_bongo
  mute_hi_conga
  open_hi_conga
  low_conga
  cabasa
  maracas
  short_guiro
  claves
  hi_wood_block
  low_wood_block

5. Instantiate a rhythmic phrase generator of 4 beats and a pool of
these possible durations:

  quarter note
  dotted eighth note
  eighth note
  sixteenth note

=cut

# The number of drummers
my $max = shift || 4;
# Beats per minute
my $bpm = shift || 90;
# The number of bars to play after all drummers have entered
my $extend = shift // 4;

my $width = length $max; # Used in sprintf below

# Setup a drum score
my $d = MIDI::Drummer::Tiny->new(
    file   => "$0.mid",
    bpm    => $bpm,
    bars   => $max * 4,
    reverb => 15,
);

# Collect the available percussion instruments
my @DRUMS = (
#    $d->hi_tom, $d->hi_mid_tom, $d->low_mid_tom, $d->low_tom, $d->hi_floor_tom, $d->low_floor_tom,
    $d->hi_bongo, $d->low_bongo, $d->mute_hi_conga, $d->open_hi_conga, $d->low_conga,
    $d->cabasa, $d->maracas, $d->short_guiro, $d->claves, $d->hi_wood_block, $d->low_wood_block,
);

die "Can't have more drummers than drums!"
    if $max > @DRUMS;

my %seen; # Bucket of drums that have been selected

my @phrases; # List of code-ref MIDI phrases

# Make a phrase generator
my $mdp = Music::Duration::Partition->new(
    size => 4,
    pool => [qw(qn den en sn)],
);

=head2 Phrases

Gather all the drummer phrases and play them simultaneously. Then
write the score to a MIDI file.

1. Build the phrases to play, one for each drummer.

2. Synchronize the phrase parts, so that they are played
simultaneously.

3. Finally, write the score to a MIDI file, named after the program
itself.

=cut

# Build the phrases played by each drummer
push @phrases, phrase($_)
    for 1 .. $max;

$d->score->synch(@phrases); # Play the phrases simultaneously

$d->write; # Write the score to a MIDI file

=head2 Subroutine

This is the meat of the program, utilizing all the things we have
setup. It generates a phrase, which is added to the list of phrases
that are then played together.

1. Get an unseen drum to use for a player, given the phrase number.
This is given by the loop that collects the phrases, above.

2. Generate a rhythmic "motif."

3. Create an anonymous subroutine that either rests or plays the
motif, given the phrase number.

3.1. The resting is done depending on the drummer entry order (into
the circle). If we are not up yet, then rest.

3.2. If not resting, play the phrase continuously until the end.

3.2.1. For each hit, get a random velocity between soft (C<f>) and
loud (C<fff>). This gives the sound a bit of dynamic texture.

4. Return this anonymous subroutine to be gathered into a list of all
drummer parts.

=cut

sub phrase {
    my ($p) = @_; # Phrase number

    # Get an unseen drum to use
    my $drum = $DRUMS[int rand @DRUMS];
    while ($seen{$drum}++) {
        $drum = $DRUMS[int rand @DRUMS];
    }

    # Create a rhythmic phrase
    my $motif = $mdp->motif;

    printf "%*d. Drum: %s, Motif: %s", $width, $p, $drum, ddc($motif);

    # Either rest or play the motif
    my $phrase = sub {
        for my $n (1 .. $d->bars + $extend) {
            # If we are not up yet, then rest
            if ($n < ($p * 4)) {
                $d->rest($d->whole);
                next;
            }
            # Otherwise play the rhythmic phrase!
            for my $dura (@$motif) {
                # Get a fluctuating velocity between f and fff
                my $vol = 'v' . (96 + int(rand 32));
                $d->note($dura, $drum, $vol);
            }
        }
    };

    return $phrase;
}

