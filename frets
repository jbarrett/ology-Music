#!/usr/bin/perl

our $VERSION = '0.07';

=head1 NAME

frets - List all possible fret positions

=head1 DESCRIPTION

This program lists all possible fret positions and flags those that are deemed
unplayable.

With the L</ARGUMENTS>, you can define fret group sizes and the number (and
name) of available fingers.  Additionally, you can show unplayable fingerings
and the reasons: A B<B>ackwards or reverse fingering and finger B<S>pan
impossibilities.

Only the max setting is required, but all the defaults are used unless given.

=head1 SYNOPSIS

 $ perl frets
 $ perl frets -v
 $ perl frets --doc
 $ perl frets --max 3
 $ perl frets -m 3 --open
 $ perl frets -m 4 --unplayable
 $ perl frets -m 4 -o -u --accumulate
 $ perl frets -fingers 'x y'
 $ perl frets -f 'x y z' -u

=head2 ARGUMENTS

  None | --help | -h | -? : Usage            (0)
  --version | -v : The current version
  --docs | -d    : The full documentation    (0)
  --max | -m     : Maximum number of frets   (4)
  --fingers | -f : Finger symbols      (i m r p)
  --numbers | -n : Indicies of fingers (1 2 3 4) *
  --open         : Use the open position     (0)
  --unplayable   : Show flagged fret groups  (0)
  --accumulate   : Tally all infractions     (0)

* Computed at run-time based on default fingers,
  if not provided as a --fingers --numbers pair.

=cut

use strict;
use warnings;

# See warnings in output context.
$|++;

use Algorithm::Combinatorics qw(
    variations_with_repetition
);
use Getopt::Long;
use List::MoreUtils qw( pairwise );
use Pod::Usage;

# Set the default values.
my $setting = {
    'fingers=s' => 'i m r p',
    'numbers=s' => '1 2 3 4',
    'help|?' => 0,
    'docs' => 0,
    'max=i' => 4,
    'open' => 0,
    'unplayable' => 0,
    'accumulate' => 0,
};

# Harvest with Go::L and call P::U.
setup($setting, \@ARGV);

# Set unspecified defaults.
set_defaults($setting);

# Fret groups (per finger).
my $v = variations_with_repetition($setting->{range}, $setting->{max});

# Line number format width. # TODO Compute instead of hard-coding.
# Loop counter for each fret group shown in the final output.
my ($width, $i) = (3, 0);

# Inspect each position AKA fret group.
while (my $position = $v->next) {

    # Flag unplayable fret groups.
    my $flag = infraction($setting, $position);

    # Concatinate pairs of fingers and frets.
    my @pairs = finger_fret($setting, $position);

    # Print a string representation of the fret group.
    printf("%*d. %s %s\n", $width, $i++, join(' ', @pairs), $flag)
        if !$flag || ($flag && $setting->{unplayable});
}

sub infraction { # Flag unplayable fret groups.

    # The position to consider.
    my($set, $pos) = @_;

    # Declare the flag to return.
    # Declare a holder for the last seen position.
    # Declare a location counter.
    my ($flag, $previous, $loc) = ('', undef, 0);

    # Inspect pairs of the position.
    for my $current (@$pos) {

        # Increment the 1st position (since we've seen at least one).
        $loc++;

        # Set the first item of the pair and move on.
        if (not defined $previous) {
            $previous = $current;
            next;
        }

        # Skip all pairs with zeros.
        if ($current && $previous) {
            # Rule: Higher frets for adjacent lower fingers are not allowed.
            if ($previous > $current) {
                $flag .= 'B'; # Flag a backward issue.
                last unless $set->{accumulate};
            }

            # Rule: Fingers spanning more than N fret(s) is not allowed.
            if ($current >= $previous + 2) {
                $flag .= 'S'; # Flag a finger span issue.
                last unless $set->{accumulate};
            }
        }

        # Update the previously seen item.
        $previous = $current;
    }

    # Return any infractions.
    return $flag;
}

sub finger_fret { # Concatinate pairs of fingers and frets.

    # The settings and current fret position.
    my($set, $pos) = @_;

    # Don't join fingers with zeros.
    # XXX Can't make this call not warn, yet.
    no warnings 'once';
    return pairwise { sprintf '%2s', $b ? $a . $b : $b }
        @{ $set->{fingers} }, @$pos;
}

sub setup { # Harvest command-line arguments and use magical POD.

    # Intake a Go::L spec=>default hashref of settings.
    my ($set, $args) = @_;

    # Auto-help if we are called with no arguments.
    pod2usage(-verbose => 1) unless @$args;

    # Set handy auto-documentation features.
    Getopt::Long::Configure(qw( auto_version auto_help ));

    # Collect the command-line arguments.
    GetOptions($set, keys %$set) || pod2usage(-verbose => 0);

    # Show documentation if requested.
    pod2usage(-verbose => 1) if $set->{help};
    pod2usage(-verbose => 2) if $set->{docs};
}

sub set_defaults { # Assign default settings to all parameters.

    # Get the settings.
    my $set = shift;

    # This is the blade with which we split things.
    my $pattern = qr/\s*[,\s]\s*/;

    # Inspect each option and add the setting if needed.
    for my $spec (keys %$set) {

        # Extract the option label from the Go::L spec.
        if ($spec =~ /^(\w+)\b.*$/) {

            # Capture label.
            my $label = $1;

            # Add the default, if not given as an argument.
            $set->{$label} = $set->{$spec} unless defined $set->{$label};
        }
    }

    # Set the original fingers to use and finger=>number order association.
    my @fingers = split $pattern, ($set->{fingers} || $set->{'fingers=s'});

    # If the max is greater than the number of fingers...
    if ($set->{max} > @fingers) {

        # Set the max to the number of fingers.
        warn "WARNING: Setting max to $set->{max}\n";
        $set->{max} = @fingers;
    }
    else {

        # Limit the finger list to the max.
        @fingers = @fingers[ 0 .. $set->{max} - 1 ];
    }

    # Set the finger list.
    $set->{fingers} = \@fingers;

    # Turn the number string into a proper array.
    my @numbers = split $pattern, ($set->{numbers} || $set->{'numbers-s'});

    # Limit the numbers list to the max.
    @numbers = @numbers[ 0 .. $set->{max} - 1 ];

    # Make a finger=>number association.
    $set->{numbers} = { pairwise { ($a => $b) } @fingers, @numbers };

    # Set the range unless given.
    $set->{range} = [ 1 .. $set->{max} ] unless exists $set->{range};

    # Prepend 0 (the open position) to the range, if requested.
    unshift @{ $set->{range} }, 0 if $set->{open};
}

__END__

=head1 EXAMPLES

 $ perl frets -m 2
   0. i1 m1
   1. i1 m2
   2. i2 m2

 $ perl frets -m 2 -o
   0.  0  0
   1.  0 m1
   2.  0 m2
   3. i1  0
   4. i1 m1
   5. i1 m2
   6. i2  0
   7. i2 m2

 $ perl frets -m 2 -o -u
  0.  0  0
  1.  0 m1
  2.  0 m2
  3. i1  0
  4. i1 m1
  5. i1 m2
  6. i2  0
  7. i2 m1 B
  8. i2 m2

 $ perl frets -m 3 -o -u -a
   0.  0  0  0 
   1.  0  0 r1 
  ...
  28. i1 m3  0 S
  29. i1 m3 r1 SB
  30. i1 m3 r2 SB
  31. i1 m3 r3 S
  ...
  62. i3 m3 r2 B
  63. i3 m3 r3 

 $ perl frets -m 4 -u -a
    0. i1 m1 r1 p1 
    1. i1 m1 r1 p2 
    2. i1 m1 r1 p3 S
  ...
  253. i4 m4 r4 p2 B
  254. i4 m4 r4 p3 B
  255. i4 m4 r4 p4

=head1 TO DO

* start=i - Fret start position (1)

* strings=i - Number of instrument strings (6)

* Allow less fingers than the max.

=head1 AUTHOR

Gene Boggs, E<lt>gene+music@ology.netE<gt>

=head1 COPYRIGHT

Copyright 2013 Gene Boggs

=head1 LICENSE

This program is free software; you can redistribute it and/or modify it under
the terms of either: the GNU General Public License as published by the Free
Software Foundation; or the Artistic License.

See http://dev.perl.org/licenses/ for more information.

=cut

