#!/usr/bin/perl

our $VERSION = '0.05';

=head1 NAME

frets - List all possible fret positions

=head1 DESCRIPTION

This program lists all possible fret positions and flags those that are deemed
unplayable.

With the L</ARGUMENTS>, you can define different sizes for fret groups and
number of available fingers.

These settings are all required, so the defaults are used unless given on the
command-line.

=head1 SYNOPSIS

 $ perl frets
 $ perl frets -v
 $ perl frets --doc
 $ perl frets --max 3
 $ perl frets -m 3 --open
 $ perl frets -m 4 -o --unplayable
 $ perl frets -fingers 'x y' -u
 $ perl frets -f 'x y z'

=head2 ARGUMENTS

  None | --help | -h | -? : Usage (0)
  --version | -v : The version
  --docs | -d : The documentation (0)
  --max | -m : Maximum number of frets (4)
  --fingers | -f : Finger symbols (i m r p)
  --open : Use the open position (0)
  --unplayable : Show impossible fret groups (0)

=cut

use strict;
use warnings;

# See warnings in output context.
$|++;

use Algorithm::Combinatorics qw(
    variations_with_repetition
);
use Getopt::Long;
use List::MoreUtils qw( pairwise );
use Pod::Usage;

# Set the default values.
my $setting = {
    'fingers=s' => 'i m r p',
    'help|?' => 0,
    'docs' => 0,
    'max=i' => 4,
    'open' => 0,
    'unplayable' => 0,
};

# Set unspecified defaults.
set_defaults($setting, \@ARGV);

# Fret groups (per finger).
my $v = variations_with_repetition($setting->{range}, $setting->{max});

# Line number format width.
my $width = 3; # TODO Compute this instead of hard-coding it.

# Loop counter for each fret group shown in the final output.
my $i = 0;

while (my $position = $v->next) {

    # Flag unplayable fret groups.
    my $flag = infraction($setting, $position);

    # Concatinate pairs of fingers and frets.
    my @pairs = pair_up($setting, $position);

    # Print a string representation of the fret group.
    printf("%*d. %s %s\n", $width, $i++, join(' ', @pairs), $flag)
        if !$flag || ($flag && $setting->{unplayable});
}

sub infraction { # Flag unplayable fret groups.

    # The position to consider.
    my($set, $pos) = @_;

    # Declare the flag to return.
    my $flag = '';

    # The open position (0) is ignored. Remove zeros.
    my @no_z = grep { $_ } @$pos;

    # Return unless there is more than one no-zero position list.
    return $flag unless @no_z > 1;

    # Declare a holder for the last seen position.
    my $previous;

    # Location counter.
    my $loc = 0;

    # Inspect pairs of the position.
    for my $current (@$pos) {

        # Increment first since we've seen at least one.
        $loc++;

        # Set the first item of the pair and move on.
        if (not defined $previous) {
            $previous = $current;
            next;
        }

        # Rule: Higher frets for lower fingers are not allowed.
        # Consider the current tail of no-zero elements.
        my @tail = @no_z[$loc - 1 .. $#no_z];
        if (grep { $previous > $_ } @tail) {
            $flag .= 'B'; # Flag a backward issue.
            last;
        }

        # Rule: Fingers spanning more than N fret(s) is not allowed.
        # TODO Absolute diff of m-r can't be more than 1. Other issues TBD
        if ($current >= $previous + 2) {
            $flag = 'S'; # Flag a finger span issue.
            last;
        }

        # Update the previously seen item.
        $previous = $current;
    }

    # Return any infractions.
    return $flag;
}

sub pair_up { # Concatinate pairs of fingers and frets.
    my($set, $pos) = @_;
    # XXX Can't make this call not warn, yet.
    no warnings 'once';
    # Don't join fingers with zeros.
    return pairwise { sprintf '%2s', $b ? $a . $b : $b }
        @{ $set->{fingers} }, @$pos;
}

sub set_defaults { # Assign default settings to all parameters.

    # Intake a Go::L spec=>default hashref of settings.
    my ($set, $args) = @_;

    # Auto-help if we are called with no arguments.
    pod2usage(-verbose => 1) unless @$args;

    # Set handy auto-documentation features.
    Getopt::Long::Configure(qw( auto_version auto_help ));

    # Collect the command-line arguments.
    GetOptions($set, keys %$set) || pod2usage(-verbose => 0);

    # Show documentation if requested.
    pod2usage(-verbose => 1) if $set->{help};
    pod2usage(-verbose => 2) if $set->{docs};

    # Inspect each option and add the setting if needed.
    for my $spec (keys %$set) {

        # Extract the option label from the Go::L spec.
        if ($spec =~ /^(\w+)\b.*$/) {

            # Capture label.
            my $label = $1;

            # Add the default, if not given as an argument.
            $set->{$label} = $set->{$spec} unless defined $set->{$label};
        }
    }

    # Set original finger=>number order association.
    my @fingers = split /\s*[,\s]\s*/, $set->{fingers};
# TODO Handle finger span with numerical association.
#    $set->{'numbered=s'} = { pairwise { ($a => $b) } @fingers, @$pos };

    # Max greater than fingers.
    if ($set->{max} > @fingers) {

        # Set the max to the number of fingers.
        $set->{max} = @fingers;
        warn "WARNING: Setting max to $set->{max}\n";

        # Set the finger list.
        $set->{fingers} = \@fingers;
    }
    # Fingers greater than max.
    else {

        # Limit the finger list to the max.
        $set->{fingers} = [ @fingers[ 0 .. $set->{max} - 1 ] ];
    }

    # Set the range unless given.
    $set->{range} = [ 1 .. $set->{max} ] unless exists $set->{range};

    # Prepend 0 (the open position) to the range, if requested.
    unshift @{ $set->{range} }, 0 if $set->{open};
}

__END__

=head1 EXAMPLES

 $ perl frets -m 2
   0. i1 m1
   1. i1 m2
   2. i2 m2

 $ perl frets -m 2 -o
   0.  0  0
   1.  0 m1
   2.  0 m2
   3. i1  0
   4. i1 m1
   5. i1 m2
   6. i2  0
   7. i2 m2

 $ perl frets -m 2 -o -u
  0.  0  0
  1.  0 m1
  2.  0 m2
  3. i1  0
  4. i1 m1
  5. i1 m2
  6. i2  0
  7. i2 m1 B
  8. i2 m2

=head1 TO DO

Handle finger spanning i<->m & r<->p span 2 frets, but m<->r is only 1 in most.

* start=i - Fret start position (1)

* strings=i - Number of instrument strings (6)

* User defined rules?

=head1 AUTHOR

Gene Boggs, E<lt>gene+music@ology.netE<gt>

=head1 COPYRIGHT

Copyright 2013 Gene Boggs

=head1 LICENSE

This program is free software; you can redistribute it and/or modify it under
the terms of either: the GNU General Public License as published by the Free
Software Foundation; or the Artistic License.

See http://dev.perl.org/licenses/ for more information.

=cut

