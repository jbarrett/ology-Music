#!/usr/bin/env perl
use strict;
use warnings;

use lib map { "$ENV{HOME}/sandbox/$_/lib" } qw(MIDI-Bassline-Walk MIDI-Util Music-Chord-Progression-Transform Music-Duration-Partition); # local author libs

use MIDI::Bassline::Walk ();
use MIDI::Util qw(setup_score midi_format);
use Music::Chord::Progression::Transform ();
use Music::Duration::Partition ();

my $bpm        = shift || 100;
my $note       = shift || 'C';
my $octave     = shift || 5;
my $quality    = shift || 'm';
my $transforms = shift || 16;
my $motifs     = shift || 2;

if ($transforms !~ /^\d+$/) {
    $transforms = [ split /,/, $transforms ];
}

my $score = setup_score(bpm => $bpm);

my @chords;

$score->synch(
    \&chords,
    \&melody,
    \&bass,
);

$score->write_score("$0.mid");

sub melody {
    my $mdp = Music::Duration::Partition->new(
        size => 4,
        pool => [qw(qn en sn)],
    );
    my @motifs = map { $mdp->motif } 1 .. $motifs;

    my $melody = MIDI::Bassline::Walk->new(
        octave  => 6,
        verbose => 1,
    );

    for my $n (0 .. $#chords) {
        my $motif = $motifs[ $n % @motifs ];
        my $notes = $melody->generate($chords[$n], scalar @$motif);
        for my $i (0 .. $#$motif) {
            $score->n($motif->[$i], $notes->[$i]);
        }
    }
}

sub chords {
    my $transform = Music::Chord::Progression::Transform->new(
        base_note     => $note,
        base_octave   => $octave,
        chord_quality => $quality,
        transforms    => $transforms,
        verbose       => 1,
    );
    my ($generated, $transforms, $chords) = $transform->generate;

    @chords = @$chords;

    $score->n('wn', midi_format(@$_)) for @$generated;
}

sub bass {
    my $bassline = MIDI::Bassline::Walk->new(
        octave  => 2,
        tonic   => 1,
        verbose => 1,
    );

    for my $chord (@chords) {
        my $notes = $bassline->generate($chord, 2);
        $score->n('hn', $_) for @$notes;
    }
}
