#!/usr/bin/env perl
use strict;
use warnings;

use lib map { "$ENV{HOME}/sandbox/$_/lib" } qw(MIDI-Bassline-Walk MIDI-Util Music-Chord-Progression-Transform Music-Duration-Partition); # local author libs

use Data::Dumper::Compact qw(ddc);
use Getopt::Long qw(GetOptions);
use MIDI::Bassline::Walk ();
use MIDI::Util qw(setup_score midi_format);
use Music::Chord::Progression::Transform ();
use Music::Duration::Partition ();

my %opt = ( # defaults:
    bpm        => 100,
    note       => 'C',
    octave     => 5,
    quality    => 'm',
    transforms => 16,
    motifs     => 2,
);
GetOptions(\%opt,
    'bpm=i',
    'note=s',
    'octave=i',
    'quality=s',
    'transforms=i',
    'motifs=i',
);

# convert a comma-separated string of transformations, if not a number
if ($opt{transforms} !~ /^\d+$/) {
    $opt{transforms} = [ split /,/, $opt{transforms} ];
}

my $score = setup_score(bpm => $opt{bpm});

my @chords; # populated by chords() and used by bass() and melody()

# play the parts simultaneously
$score->synch(
    \&chords,
    \&melody,
    \&bass,
);

# write the score to a midi file
$score->write_score("$0.mid");

sub melody {
    my $mdp = Music::Duration::Partition->new(
        size => 4,
        pool => [qw(qn en sn)],
    );
    my @motifs = map { $mdp->motif } 1 .. $opt{motifs};

    my $melody = MIDI::Bassline::Walk->new(
        octave  => 6,
#        verbose => 1,
    );

    for my $n (0 .. $#chords) {
        my $motif = $motifs[ $n % @motifs ];
        # generate notes for the number of motif durations, given the nth chord
        my $notes = $melody->generate($chords[$n], scalar @$motif);
        for my $i (0 .. $#$motif) {
            $score->n($motif->[$i], $notes->[$i]);
        }
    }
}

sub chords {
    my $transform = Music::Chord::Progression::Transform->new(
        base_note     => $opt{note},
        base_octave   => $opt{octave},
        chord_quality => $opt{quality},
        transforms    => $opt{transforms},
#        verbose       => 1,
    );
    my ($generated, $transforms, $chords) = $transform->generate;
    print ddc($transforms, {max_width=>512});
    print ddc($chords, {max_width=>512});

    @chords = @$chords;

    $score->n('wn', midi_format(@$_)) for @$generated;
}

sub bass {
    my $bassline = MIDI::Bassline::Walk->new(
        octave  => 2,
        tonic   => 1,
#        verbose => 1,
    );

    for my $chord (@chords) {
        my $notes = $bassline->generate($chord, 2);
        $score->n('hn', $_) for @$notes;
    }
}
