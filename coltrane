#!/usr/bin/env perl
use strict;
use warnings;

# Writeup: https://ology.github.io/2022/04/23/coltranes-mystery-music-diagram/

use lib map { "$ENV{HOME}/sandbox/$_/lib" } qw(MIDI-Drummer-Tiny Music-ScaleNote);
use MIDI::Drummer::Tiny;
use MIDI::Util qw(set_chan_patch);
use Music::ScaleNote;

use constant HEAD   => 0;
use constant MIDDLE => 2;
use constant TAIL   => 4;
use constant LEFT   => -1;
use constant RIGHT  => 1;
use constant FORMAT  => 'midi';

my $max   = shift || 12;
my $bpm   = shift || 90;
my $patch = shift || 66; # soprano sax=64, alto=65, tenor=66, bari=67

my $channel = 0;

my @outer = (
    [qw(Af Bf C  D  E )],
    [qw(Fs Af Bf C  D )],
    [qw(E  Fs Af Bf C )],
    [qw(D  E  Fs Af Bf)],
    [qw(C  D  E  Fs Af)],
    [qw(Bf C  D  E  Fs)],
);
my @inner = (
    [qw(Cs Ef F  G  A )],
    [qw(B  Cs Ef F  G )],
    [qw(A  B  Cs Ef F )],
    [qw(G  A  B  Cs Ef)],
    [qw(F  G  A  B  Cs)],
    [qw(Ef F  G  A  B )],
);

my $inner_scale = Music::ScaleNote->new(
  scale_note  => 'C#',
  scale_name  => 'wholetone',
  note_format => FORMAT,
  verbose     => 1,
);
my $outer_scale = Music::ScaleNote->new(
  scale_note  => 'C',
  scale_name  => 'wholetone',
  note_format => FORMAT,
  verbose     => 1,
);

my $d = MIDI::Drummer::Tiny->new(
    file => "$0.mid",
    bpm  => $bpm,
    bars => $max,
);

$d->sync(
    \&drums,
    \&coltrane,
);

$d->write;

sub coltrane {
    set_chan_patch($d->score, $channel, $patch);

    my $in_out       = int rand 2;
    my $section      = $in_out ? $inner[ int rand @inner ] : $outer[ int rand @outer ];
    my $index        = int rand @$section;
    my $current_note = $section->[$index];
    my $direction    = int rand 2 ? RIGHT : LEFT;
    my $next_note;

    for my $n (1 .. $max) {
        if (($index == HEAD && $direction == LEFT) || ($index == TAIL && $direction == RIGHT)) {
            # step() ignores scale type
            $next_note = $inner_scale->step(note_name => $current_note, steps => $direction);
            $in_out = !$in_out;
        }
        else {
            my $roll = int rand 2;
            if ($index == MIDDLE && $roll) {
                $next_note = $inner_scale->step(note_name => $current_note, steps => $direction);
                $in_out = !$in_out;
            }
            else {
                $next_note = $in_out
                    ? $inner_scale->get_offset(note_name => $current_note, offset => $direction)
                    : $outer_scale->get_offset(note_name => $current_note, offset => $direction);
            }
        }
        my $formatted = $next_note->format(FORMAT);
warn __PACKAGE__,' L',__LINE__,' ',,"[@$section] $index, $current_note, $direction => $formatted\n";

        # Iterate the parameters:
        $section = $in_out ? $inner[ int rand @inner ] : $outer[ int rand @outer ];
        $index = int rand @$section;
        $current_note = $section->[$index];
        $direction = int rand 2 ? RIGHT : LEFT;
    }
}

sub drums {
    $d->metronome44swing; # swing for the number of bars
    $d->note( $d->quarter, $d->ride1, $d->kick );
}
