#!/usr/bin/env perl

# Attempt to imitate John Coltrane via his mysterious circle diagram.
# Writeup: https://ology.github.io/2022/04/23/coltranes-mystery-music-diagram/

use strict;
use warnings;

no autovivification;

use List::SomeUtils qw(first_index);
#use lib map { "$ENV{HOME}/sandbox/$_/lib" } qw(MIDI-Drummer-Tiny Music-Duration-Partition Music-ScaleNote);
use MIDI::Drummer::Tiny;
use MIDI::Util qw(set_chan_patch);
use Music::Duration::Partition;
use Music::ScaleNote;

use constant HEAD   => 0;      # diagram index
use constant MIDDLE => 2;      # "
use constant TAIL   => 4;      # "
use constant LEFT   => -1;     # direction
use constant RIGHT  => 1;      # "
use constant FORMAT => 'midi';
use constant HIGH   => 6;      # octave bound
use constant LOW    => 3;      # "

my $max    = shift || 12;  # number of measures to play
my $bpm    = shift || 100; # beats per minute
my $patch  = shift || 66;  # soprano sax=64, alto=65, tenor=66, bari=67
my $octave = shift || 4;   # starting octave

my $channel = 0;

# describe Coltrane's circle diagram
my @outer = (
    [qw( Af Bf C  D  E  )],
    [qw( Gf Af Bf C  D  )],
    [qw( E  Gf Af Bf C  )],
    [qw( D  E  Gf Af Bf )],
    [qw( C  D  E  Gf Af )],
    [qw( Bf C  D  E  Gf )],
);
my @inner = (
    [qw( Df Ef F  G  A  )],
    [qw( B  Df Ef F  G  )],
    [qw( A  B  Df Ef F  )],
    [qw( G  A  B  Df Ef )],
    [qw( F  G  A  B  Df )],
    [qw( Ef F  G  A  B  )],
);
my %outer_links = (
    0 => {
        Af => [5],
        C  => [5,0],
        E  => [0],
    },
    1 => {
        Gf => [0],
        Bf => [0,1],
        D  => [1],
    },
    2 => {
        E  => [1],
        Af => [1,2],
        C  => [2],
    },
    3 => {
        D  => [2],
        Gf => [2,3],
        Bf => [3],
    },
    4 => {
        C  => [3],
        E  => [3,4],
        Af => [4],
    },
    5 => {
        Bf => [4],
        D  => [4,5],
        Gf => [5],
    },
);
my %inner_links = (
    0 => {
        Df => [0],
        F  => [0,1],
        A  => [1],
    },
    1 => {
        B  => [1],
        Ef => [1,2],
        G  => [2],
    },
    2 => {
        A  => [2],
        Df => [2,3],
        F  => [3],
    },
    3 => {
        G  => [3],
        B  => [3,4],
        Ef => [4],
    },
    4 => {
        F  => [4],
        A  => [4,5],
        Df => [5],
    },
    5 => {
        Ef => [5],
        G  => [5,0],
        B  => [0],
    },
);

my $outer_scale = Music::ScaleNote->new(
  scale_note  => 'C',
  scale_name  => 'wholetone',
  note_format => FORMAT,
  flat        => 1,
#  verbose     => 1,
);
my $inner_scale = Music::ScaleNote->new(
  scale_note  => 'C#',
  scale_name  => 'wholetone',
  note_format => FORMAT,
  flat        => 1,
#  verbose     => 1,
);

my $d = MIDI::Drummer::Tiny->new(
    file => "$0.mid",
    bpm  => $bpm,
    bars => $max,
);

$d->sync(
    \&drums,
    \&coltrane,
);

$d->write;

sub drums {
    $d->metronome44swing; # swing for the number of bars
    $d->note($d->quarter, $d->ride1, $d->kick);
}

sub coltrane {
    set_chan_patch($d->score, $channel, $patch);

    # initial conditions
    my $in_out       = int rand 2; # choose a ring, inner or outer
    my $section_num  = int rand @inner; # choose a section of the ring
    my $section      = $in_out ? $inner[$section_num] : $outer[$section_num];
    my $index        = int rand @$section; # get the current note & its index
    my $current_note = $section->[$index]; # "
    my $direction    = int rand 2 ? RIGHT : LEFT; # which way are we headed?
    my $next_note; # The new note to generate
    my $formatted; # "

    # initialize a phrase generator
    my $mdp = Music::Duration::Partition->new(
        size    => 4,
        pool    => [qw/ qn tqn en ten sn /], # XXX but what note durations
        groups  => [    1, 3,  1, 3,  2   ], # XXX did Coltrane actually
        weights => [    1, 1,  2, 2,  2   ], # XXX play?
    );
    my @motifs = map { $mdp->motif } 1 .. 3;

    # produce max bars of phrases
    for my $n (1 .. $max) {
        warn sprintf "%d. %d (%s)[%d] = %s%d, %d\n",
            $n, $section_num, "@$section", $index, $current_note, $octave, $direction;

        my $motif = $motifs[ int rand @motifs ];

        for my $m (@$motif) {
            if (($index == HEAD && $direction == LEFT) || ($index == TAIL && $direction == RIGHT)) {
                ($in_out, $section_num, $index, $formatted, $octave, $section) = step_in_out(
                    $next_note,
                    $in_out,
                    $inner_scale,
                    $outer_scale,
                    $octave,
                    $current_note,
                    $direction,
                    $formatted,
                    $section_num,
                    $section,
                    \@inner,
                    \@outer,
                    \%inner_links,
                    \%outer_links,
                    $index,
                );
            }
            else {
                my $roll = int rand 2;
                if ($index == MIDDLE && $roll) {
                    ($in_out, $section_num, $index, $formatted, $octave, $section) = step_in_out(
                        $next_note,
                        $in_out,
                        $inner_scale,
                        $outer_scale,
                        $octave,
                        $current_note,
                        $direction,
                        $formatted,
                        $section_num,
                        $section,
                        \@inner,
                        \@outer,
                        \%inner_links,
                        \%outer_links,
                        $index,
                    );
                }
                else {
                    $next_note = $in_out
                        ? $inner_scale->get_offset(note_name => $current_note . $octave, offset => $direction)
                        : $outer_scale->get_offset(note_name => $current_note . $octave, offset => $direction);

                    $formatted = $next_note->format(FORMAT);
                    ($octave = $formatted) =~ s/^[A-G][fs]?(\d+)$/$1/;
                    $octave-- if $octave > HIGH;
                    $octave++ if $octave < LOW;
                    (my $sans_octave = $formatted) =~ s/\d+$//;

                    $index = first_index { $_ eq $sans_octave } @$section;
                }
            }

            # add the motif note to the score
            $d->note($m, $formatted);

            warn "\tNew note: (@$section)[$index] = $formatted, $m\n";

            # iterate the parameters
            $current_note = $section->[$index];
            $direction    = int rand 2 ? RIGHT : LEFT;
        }
    }
}

sub step_in_out {
    # XXX This mass argument import is ugly at best
    my (
        $next_note,
        $in_out,
        $inner_scale,
        $outer_scale,
        $octave,
        $current_note,
        $direction,
        $formatted,
        $section_num,
        $section,
        $inner,
        $outer,
        $inner_links,
        $outer_links,
        $index,
    ) = @_;

    $next_note = $in_out
        ? $inner_scale->step(note_name => $current_note . $octave, steps => $direction)
        : $outer_scale->step(note_name => $current_note . $octave, steps => $direction);

    $formatted = $next_note->format(FORMAT);
    ($octave = $formatted) =~ s/^[A-G][fs]?(\d+)$/$1/;
    $octave-- if $octave > HIGH;
    $octave++ if $octave < LOW;
    (my $sans_octave = $formatted) =~ s/\d+$//;

    $in_out = $in_out ? 0 : 1; # jump rings
    if ($in_out) {
        ($section_num, $section) = get_section(
            $outer_links,
            $section_num,
            $current_note,
            $direction,
            $inner,
            $section,
        );
    }
    else {
        ($section_num, $section) = get_section(
            $inner_links,
            $section_num,
            $current_note,
            $direction,
            $outer,
            $section,
        );
    }

    $index = first_index { $_ eq $sans_octave } @$section;

    return $in_out, $section_num, $index, $formatted, $octave, $section;
}

sub get_section {
    my (
        $links,
        $section_num,
        $current_note,
        $direction,
        $sections,
        $section,
    ) = @_;

    my $i = exists $links->{$section_num}{$current_note}
        && defined $links->{$section_num}{$current_note}[RIGHT]
        && $direction == RIGHT ? 1 : 0;

    $section_num = $links->{$section_num}{$current_note}[$i];

    $section = $sections->[$section_num];

    return $section_num, $section;
}
