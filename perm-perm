#!/usr/bin/env perl
use strict;
use warnings;

use MIDI::Simple;
use Math::Combinatorics;
use List::Util qw( shuffle );
use List::UtilsBy qw( zip_by );

my @treb_notes = qw( C5 D5 E5 );
my @treb_dura  = qw( en en den );
my @bass_notes = qw( C3 F3 G3 );
my @bass_dura  = qw( en qn qn );

my @treb_combos = shuffle permute(@treb_notes);
my @treb_dura_combos = shuffle permute(@treb_dura);
my @bass_combos = shuffle permute(@bass_notes);
my @bass_dura_combos = shuffle permute(@bass_dura);

my $score = setup_midi( scalar(@treb_notes), 1, 0, 120 );

for my $i ( 0 .. @treb_combos - 1 ) {
    for my $j ( 0 .. @{ $treb_combos[$i] } - 1 ) {
        if ( $treb_dura_combos[$i][$j] eq $bass_dura_combos[$i][$j] ) {
            $score->n(
                $treb_dura_combos[$i][$j],
                $treb_combos[$i][$j],
                $bass_combos[$i][$j]
            );
        }
        else {
            $score->n( $treb_dura_combos[$i][$j], $treb_combos[$i][$j] );
            $score->n( $bass_dura_combos[$i][$j], $bass_combos[$i][$j] );
        }
    }
}

$score->write_score($0.'.mid');

sub setup_midi {
    my ( $sig, $instrument, $patch, $volume ) = @_;
    my $score = MIDI::Simple->new_score();
    $score->Volume($volume);
    # Lead-in
    $score->Channel(9);
    $score->n( 'qn', 42 ) for 1 .. $sig;
    # Passage
    $score->Channel($instrument);
    $score->patch_change( $instrument, $patch );
    return $score;
}
