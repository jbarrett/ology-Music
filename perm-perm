#!/usr/bin/env perl
use strict;
use warnings;

use Math::Combinatorics;
use MIDI::Simple;
use Music::Scala;

# Choose wisely, Grasshopper
my $bass_notes   = @ARGV ? [split /,/, shift @ARGV] : [qw( 9 2 4 7 21 )]; # A3 D3 E3 G3 A5
my $treble_notes = @ARGV ? [split /,/, shift @ARGV] : [qw( 0 2 4 5 9 )];  # C5 D5 E5 F5 A4
my $critical_t   = 0; # Zero means "show everything"
my $critical_b   = 0; # "

# Perl-MIDI named pitches and integer notation
my %name = (
    0  => 'C4',
    1  => 'Cs4',
    2  => 'D4',
    3  => 'Ds4',
    4  => 'E4',
    5  => 'F4',
    6  => 'Fs4',
    7  => 'G4',
    8  => 'Gs4',
    9  => 'A4',
    10 => 'As4',
    11 => 'B4',
    21 => 'A5',
);

# Use the standard 12-tone scale
my @scale = qw( 1 16/15 9/8 6/5 5/4 4/3 25/18 3/2 8/5 5/3 16/9 15/8 2 );
my $scala = Music::Scala->new;
$scala->set_concertfreq(264);
$scala->set_notes(@scale);

my $score = set_score();

# Set the number of treble permutaions seen
my $j = 0;

# Instantiate a combinatorics object for the bass notes
my $treble_mc = Math::Combinatorics->new( data => $treble_notes );

# Iterate over the treble notes
TREBLE: while ( my @treble = $treble_mc->next_permutation ) {
    # Are we critical?
    last TREBLE if $critical_t && $j > $critical_t - 1;
    # Iterate the number of permutations
    $j++;

    # Find the physical frequencies of the notes
    my @treble_freq = $scala->interval2freq(@treble);
    # Set item precision
    @treble_freq = mapf(@treble_freq);

    # Set the number of bass permutaions seen
    my $i = 0;

    # Instantiate a combinatorics object for the bass notes
    my $bass_mc = Math::Combinatorics->new( data => $bass_notes );

    # Iterate over the bass notes
    BASS: while ( my @bass = $bass_mc->next_permutation ) {
        # Are we critical?
        last BASS if $critical_b && $i > $critical_b - 1;
        # Iterate the number of permutations
        $i++;

        # Find the physical frequencies of the notes
        my @bass_freq = $scala->interval2freq(@bass);

        # Set item precision
        @bass_freq = mapf(@bass_freq);

        # List the pitch names
        my @bass_names;
        push @bass_names, $name{ $bass[$_] } for 0 .. @bass - 1;

        # Find the interval set comprising each bass and treble note
        my @intervals = ();
        for my $n ( 0 .. @bass - 1 ) {
            # An interval is the absolute difference of two pitches, modulo the number of semitones
            push @intervals, abs( $bass[$n] - $treble[$n] ) % 12;
        }

        # List the pitch names
        my @treble_names;
        push @treble_names, $name{ $treble[$_] } for 0 .. @treble - 1;

        # Add the interval to the score
        $score->n( { $score->Cookies }->{unit}, $name{ $treble[$_] }, $name{ $bass[$_] } )
            for 0 .. @treble - 1;

        # Output the permutations, frequencies and intervals
        printf "%d,%d\n\t%11s -> %s -> %11s\n\t%11s -> %s -> %11s\n      =\t%s\n",
            $j, $i,
            joinf(@treble), "@treble_freq", joinf(@treble_names),
            joinf(@bass),   "@bass_freq",   joinf(@bass_names),
            joinf(@intervals);
    }
}

$score->write_score( $0 . '.mid' );

sub joinf { # Turn a list of integers into 2 digit precision
    return join ' ', map { sprintf '%2s', $_ } @_;
}

sub mapf { # Turn a list of floats into 2 digit precision
    return map { sprintf '%.2f', $_ } @_;
}

sub set_score {
    my %conf = (
        tempo     => 187_500, # = 375_000 / 2 = 240BPM, #140_000, # BPM = 428.571428571428571
        volume    => 100,
        signature => 4,
        unit      => 'qn',
        channel   => 1,
        patch     => 13,
        octave    => 4,
        kit       => 9,
        pad       => 38,
    );

    my $score = MIDI::Simple->new_score();

    $score->Volume($conf{volume});
    $score->set_tempo($conf{tempo});

    # lead-in
    $score->Channel($conf{kit});
    $score->n($conf{unit}, $conf{pad}) for 1 .. $conf{signature};

    # passage
    $score->patch_change($conf{channel}, $conf{patch});
    $score->Channel($conf{channel});
    $score->Octave($conf{octave});
    $score->Cookies(unit => $conf{unit});

    return $score;
}
