#!/usr/bin/env perl
use strict;
use warnings;

use Math::Trig ();
use SVG qw(title);

use constant PI     => 2 * atan2(1,0);
use constant HALF   => PI / 2;
use constant DOUBLE => 2 * PI;

my $phrase   = shift || 'x...x.x...x.x...'; # pattern to render
my $diameter = shift || 512; # size of the circle

my $show_marks  = length $phrase; # circular beats marks to display
my $fill        = 'white';
my $beat_fill   = 'gray';
my $border      = 'green';
my $total_marks = 60; # maximum number of note markers
# NB: Changing the border_size and beat_radius apparently messes up placement
my $border_size = 15; # chart margin
my $beat_radius = 11; # radius for sub-circle markings
my $radius      = $diameter / 2;
my $frame_size  = $diameter + 2 * $border_size;

my $i = 0;
my @onsets; # beats to draw
for my $beat (split //, $phrase) {
    push @onsets, $i if $beat eq 'x';
    $i++;
}

my $svg = SVG->new(
    width  => $frame_size,
    height => $frame_size,
);
$svg->title()->cdata('Rhythm Necklace');

my $style = $svg->group(
    id    => 'style-group',
    style => {
        stroke => $border,
        fill   => $fill,
    },
);

$style->circle(
    id => 'style-group-circle',
    cx => $frame_size / 2,
    cy => $frame_size / 2,
    r  => $radius,
);

# compute the circle positions
my @marks = map { $_ * $total_marks / $show_marks } 1 .. $show_marks;

# keep track of the beat coordinates
my @coordinates;

# display the circle positions
for my $mark (@marks) {
    my $p = coordinate($mark, $total_marks, $radius);
    push @coordinates, $p;

    $style->circle(
        id => $mark . '-style-group-beat-circle',
        cx => $p->[0] + $beat_radius + $border_size / 3,
        cy => $p->[1] + $beat_radius + $border_size / 3,
        r  => $beat_radius,
    );
}

print $svg->xmlify;

sub coordinate {
    my ($p, $total, $radius) = @_;

    # compute the analog minute time equivalent
    my $analog = $p / $total * DOUBLE - HALF;

    # get the coordinate of the time value
    my $coord = [
        $radius + $radius * cos($analog),
        $radius + $radius * sin($analog)
    ];

    return $coord;
}
