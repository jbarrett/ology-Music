#!/usr/bin/env perl
use strict;
use warnings;

# Examples: http://techn.ology.net/algorithmic-ambient-audio/
#           https://youtu.be/Fpp5ScH_8OY - 20BPM audio rendering
# perl follow 9 '4,16,69,70' 120 pminor A

# General MIDI patches that are audible and aren't horrible:
# 0 1 2 4 5 7 8 9 13 16 21 24 25 26 32 34 35 40 42 60 68 69 70 71 72 73 74 79

use lib '/Users/gene/sandbox/MIDI-Util/lib';
use MIDI::Util;
use Music::Scales;

my $group   = shift || 1; # Groups of 3 bars
my $patches = shift || '4,16,69,70'; # See above for good ones
my $bpm     = shift || 100; # Beats per minute
my $name    = shift || 'pentatonic';
my $note    = shift || 'C'; # Bf, Cs, etc.
my $octave  = shift || 4;

# 9 possible 3 bar phrases
my $possibles = [           #   |   |   |   |  <- 3 measures
    [qw/ wn wr wr /],       # 0 ####.   .   .  <- Whole note
    [qw/ qr wn dhr wr /],   # 1 .####   .   .
    [qw/ hr wn hr wr /],    # 2 . ####  .   .
    [qw/ dhr wn qr wr /],   # 3 .  #### .   .
    [qw/ wr wn wr /],       # 4 .   ####.   .
    [qw/ wr qr wn dhr /],   # 5 .   .####   .
    [qw/ wr hr wn hr /],    # 6 .   . ####  .
    [qw/ wr dhr wn qr /],   # 7 .   .  #### .
    [qw/ wr wr wn /],       # 8 .   .   ####.
];

$patches = [ split /,/, $patches ];
die "Can't have more than 14 patches.\n"
    if @$patches > 14;

my @scale = get_scale_notes($note, $name);

my $score = MIDI::Util::setup_score(bpm => $bpm, octave => $octave);

my $channel = 0;

# Roll as many times as there are patches
$score->synch(
    (map { \&roll } 1 .. @$patches),
    \&drums,
    \&bass,
);

# Write the tonic to the end of the score
$score->n('wn', $scale[0]);

$score->write_score("$0.mid");

sub roll {
    my $patch = $patches->[ $channel > 9 ? $channel - 1 : $channel ];
    $channel++ if $channel == 9; # Skip the drum channel
    MIDI::Util::set_chan_patch($score, $channel++, $patch);

    for my $i (0 .. $group - 1) {
        my $roll = int rand @$possibles;
        print $channel, '. Adding roll #', $roll, " for patch: $patch\n";
        print "\t";
        for my $duration (@{ $possibles->[$roll] }) {
            my $trigger = substr $duration, length($duration) - 1, 1;
            if ($trigger eq 'n') {
                my $n = $scale[int rand @scale];
                print "$n ";
                $score->n($duration, $n);
            }
            else {
                (my $dura = $duration) =~ s/r/n/;
                $score->r($dura);
            }
        }
        print "\n";
    }
}

sub bass {
    my $patch = 35;
    $channel++ if $channel == 9; # Skip the drum channel
    MIDI::Util::set_chan_patch($score, $channel++, $patch);
    $score->Volume(100);

    for my $i (0 .. $group - 1) {
        print "$channel. Adding bass with patch: $patch\n";
        print "\t";
        for my $duration (qw/ hn hn hn hn hn hn /) { # 3 measures of half-notes
            my $n = $scale[int rand @scale] . 3;
            print "$n ";
            $score->n($duration, $n);
        }
        print "\n";
    }
}

sub drums {
    MIDI::Util::set_chan_patch($score, 9, 0);
    $score->Volume(50);
    for my $i (0 .. $group - 1) {
        for my $duration (('qn') x 12) { # 3 measures of quarter-notes
            $score->n($duration, 44);
        }
    }
}
