#!/usr/bin/env perl

# MP4: https://youtu.be/vstdXn_ufVY

use strict;
use warnings;

use lib '/Users/gene/sandbox/MIDI-Util/lib';
use MIDI::Util;
use Music::Scales;
use Music::Voss qw/ powers /;

my $max = shift || 64;
my $bpm = shift || 200;

my $scale_note          = 'C';
my $alto_scale_name     = 'minor';
my $tenor_scale_name    = 'pminor';
my $baritone_scale_name = 'pminor';

my $alto_patch     = 69;
my $tenor_patch    = 70;
my $baritone_patch = 42;

my $quarter = 'qn';
my $half    = 'hn';
my $whole   = 'wn';

my $score = MIDI::Util::setup_score( lead_in => 0, bpm => $bpm );

$score->synch(
    \&alto,
    \&tenor,
    \&baritone,
);

$score->write_score("$0.mid");

sub alto {
    MIDI::Util::set_chan_patch( $score, 0, $alto_patch );

    my @scale = get_scale( $scale_note, 5, $alto_scale_name );
    my $seed  = [ map { sub { int rand 2 } } @scale ];
    my $genf  = powers( calls => $seed );

    my $i = 0;

    for my $n ( 0 .. $max - 1 ) {
        if ( $n % 4 == 0 ) {
            for ( 1 .. 4 ) {
                my $note = $scale[ $genf->($n) ];
                $score->n( $quarter, $note );
            }

            if ( $i % 3 == 0 ) {
                my $note = $scale[ $genf->($n) ];
                $score->n( $quarter, $note );
            }
        }
        else {
            $score->r($whole);
        }

        $i++;
    }

    $score->r($whole);
}

sub tenor {
    MIDI::Util::set_chan_patch( $score, 1, $tenor_patch );

    my @scale = get_scale( $scale_note, 4, $tenor_scale_name );
    my $seed  = [ map { sub { int rand 2 } } @scale ];
    my $genf  = powers( calls => $seed );

    for my $n ( 0 .. $max - 1 ) {
        if ( $n < 8 ) {
            $score->r($whole);
        }
        else {
            if ( $n % 2 == 0 ) {
                my $note = $scale[ $genf->($n) ];
                $score->n( $half, $note );
            }
            else {
                $score->r($half);
            }

            if ( $n % 3 == 0 ) {
                my $note = $scale[ $genf->($n) ];
                $score->n( $half, $note );
            }
            else {
                $score->r($half);
            }
        }
    }

    $score->n( $whole, $scale[0] );
}

sub baritone {
    MIDI::Util::set_chan_patch( $score, 2, $baritone_patch );

    my @scale = get_scale( $scale_note, 3, $baritone_scale_name );
    my $seed  = [ map { sub { int rand 2 } } @scale ];
    my $genf  = powers( calls => $seed );

    for my $n ( 0 .. $max - 1 ) {
        if ( $n < 8 ) {
            $score->r($whole);
        }
        else {
            my $note = $scale[ $genf->($n) ];
            $score->n( $whole, $note );
        }
    }

    $score->n( $whole, $scale[0] );
}

sub get_scale {
    my ( $note, $octave, $name ) = @_;

    my @scale = map { $_ . $octave } get_scale_notes( $note, $name );
    for ( @scale ) {
        s/#/s/;
        s/b/f/;
    }

    return @scale;
}
