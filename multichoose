#!/usr/bin/perl
#
# List all possible fret fingerings - gene@ology.net
#
use strict;
use warnings;

use Getopt::Long;
use List::MoreUtils qw( pairwise );
use Math::Combinatorics;

our $VERSION = '0.01';

# See warnings in output context.
$|++;

# Set the default values for our computations.
my $opt = {
    # The fret start position.
    'start=i'    => 1,
    # The number of frets.
    'frets=i'    => 4,
    # The number of instrument strings.
    'strings=i'  => 6, # TODO Feature coming soon...
    # The fret positions. 0 = open string & 4 is "frets from the start"
    'range=i@'   => [qw( 0 1 2 3 4 )],
    # Set the finger symbols. i=index m=middle r=ring p=pinky
    #   Options: _=none x=muted *=harmonic
    'fingers=s@' => [qw( i m r p )],
    # Adjacent finger span. i<->m & r<->p span 2 frets, but m<->r is 1.
    'span=i@'    => [qw( 2 1 2 )], # TODO Feature coming soon...
};

# Collect the command-line options.
GetOptions($opt, keys %$opt);

# Set the unspecified defaults.
set_defaults($opt);

# Make an object to hold all possible fret positions.
my $c = Math::Combinatorics->new(
    count => $opt->{frets},
    data => $opt->{range},
    frequency => [ map{ $opt->{frets} } 1 .. @{$opt->{range}} ],
);

# Line number format width.
my $n = 3; # TODO Compute with Math::Big?

# Loop counter for each fret group used in the final output.
my $i = 0;

# Visit each multiset.
while (my @m = $c->next_multiset) {

    # Make an object to hold this positions fret groups.
    my $p = Math::Combinatorics->new(
        data => \@m,
        frequency => [ map { 1 } @m ],
    );

    # Visit each set.
    while (my @s = $p->next_string) {

        # This is a string to hold reasons why this group is unplayable.
        my $flag = '';

        # Consider adjacent pairs of the fret group.
        for my $x (1 .. @s - 1) {

            # Hide the ugliness of array subscript indexing.
            my $previous = $s[$x - 1];
            my $current  = $s[$x];

            # Rule:
            # "Next to the adjacent" can only span 2 frets. Etc.
            # TODO This logic restricts by fret, not finger, yet.
            # E.g. Middle-ring finger only spans 1 fret in most people.
            if ($previous && $current && $previous != $current
                && $current >= $previous + 2) {

                $flag = 's'; # Flag a finger span issue.
                last;
            }
        }

        # If this group has no "playability infractions", proceed.
        unless ($flag) {

            # The open position (0) is ignored. Remove zeros.
            my @no_z = grep { defined $_ && $_ } @s;

            if (@no_z >= 2) {

                # Consider adjacent pairs of the no-zero fret group.
                for my $x (1 .. @no_z - 1) {

                    # Consider the current tail of no-zero elements.
                    my @sliver = @no_z[$x .. @no_z - 1];

                    # Rule:
                    # Higher fret numbers for lower fingers are not allowed.
                    if (grep { $no_z[$x - 1] > $_ } @sliver) {

                        $flag = 'b'; # Flag a backward issue
                        last;
                    }
                }
            }
        }

        # Concatinate pairs of fingers and frets.
        my @limited = @{$opt->{fingers}}[0 .. @s - 1];
        my @pairs = pairwise { $a . $b } @limited, @s;

        # Print a string representation of the fret group.
        printf "%*d. %s %s\n", $n, ++$i, join(' ', @pairs), $flag;
    }
}

sub set_defaults {
    # Intake a hashref of default Go::L spec=>default entries.
    my $options = shift;

    # Inspect each option.
    for my $spec (keys %$options) {

        # Extract the option label from the spec.
        (my $label = $spec) =~ s/^(\w+)\b.+$/$1/;

        # Add the default value, if it has not already been given.
        $options->{$label} ||= $options->{$spec};
    }
}

