#!/usr/bin/perl

=head1 NAME

multichoose - List all possible fret positions

=head1 DESCRIPTION

This program lists all possible fret positions and flags those that are deemed
unplayable.

With the L</ARGUMENTS>, you can define different sizes for fret groups and
number of available fingers.

These settings are all required, so the defaults are used unless given on the
command_line.

=head1 SYNOPSIS

 $ perl multichoose
 $ perl multichoose -v
 $ perl multichoose --doc
 $ perl multichoose --max 4 --open
 $ perl multichoose --max 4 --open --unplayable
 $ perl multichoose -m 2 -o -u --fingers 'x y'
 $ perl multichoose -m 3 -o -u -f 'x y z'

=head2 ARGUMENTS

  None | --help | -h | -? : Usage (0)
  --version | -v : The version!
  --doc | -d : The documentation (0)
  --max | -m : Maximum number of frets (4)
  --fingers | -f : Finger symbols (i m r p)
  --open : Use the open position (0)
  --unplayable : Show impossible fret groups (0)

=cut

use strict;
use warnings;

use Getopt::Long;
use List::MoreUtils qw( pairwise );
use Math::Combinatorics;
use Pod::Usage;

our $VERSION = '0.03';

# Set the default values.
my $opt = {
    'fingers=s' => 'i m r p',
    'help|?' => 0,
    'doc' => 0,
    'max=i' => 4,
    'open' => 0,
    'unplayable' => 0,
};

# See warnings in output context.
$|++;

# Auto-help if we are called with no arguments.
pod2usage(-verbose => 1) unless @ARGV;

# Set handy auto-documentation features.
Getopt::Long::Configure(qw( auto_version auto_help ));

# Collect the command-line arguments.
GetOptions($opt, keys %$opt) || pod2usage(-verbose => 0);

# Show documentation if requested.
pod2usage(-verbose => 1) if $opt->{help};
pod2usage(-verbose => 2) if $opt->{man};

# Set unspecified defaults.
set_defaults($opt);

# Make an object to hold all possible fret positions.
my $c = Math::Combinatorics->new(
    count => $opt->{max},
    data => $opt->{range},
    frequency => [ map{ $opt->{max} } @{ $opt->{range} } ],
);

# Line number format width.
my $n = 3; # XXX Hard-coding. Compute with Math::Big?

# Loop counter for each fret group shown in the final output.
my $i = 0;

# Visit each multiset.
while (my @m = $c->next_multiset) {

    # Make an object to hold this positions fret groups.
    my $p = Math::Combinatorics->new(
        data => \@m,
        frequency => [ map { 1 } @m ],
    );

    # Visit each set.
    while (my @s = $p->next_string) {

        # This is a string to hold reasons why this group is unplayable.
        my $flag = '';

        # Consider adjacent pairs of the fret group.
        for my $x (1 .. @s - 1) {

            # Hide the ugliness of array subscript indexing.
            my $previous = $s[$x - 1];
            my $current  = $s[$x];

            # Rule: Restrict spanning.
            if ($previous && $current && $previous != $current
                && $current >= $previous + 2) {

                $flag = 's'; # Flag a finger span issue.
                last;
            }
        }

        # Proceed if this group has no "play-infractions" flagged.
        unless ($flag) {

            # The open position (0) is ignored. Remove zeros.
            my @no_z = grep { defined $_ && $_ } @s;

            # Is there a pair of elements?
            if (@no_z >= 2) {

                # Consider adjacent pairs of the no-zero fret group.
                for my $x (1 .. @no_z - 1) {

                    # Consider the current tail of no-zero elements.
                    my @sliver = @no_z[$x .. @no_z - 1];

                    # Rule: Higher frets for lower fingers are not allowed.
                    if (grep { $no_z[$x - 1] > $_ } @sliver) {

                        $flag = 'b'; # Flag a backward issue
                        last;
                    }
                }
            }
        }

        # Concatinate pairs of fingers and frets.
        my @pairs;
        {
            # XXX Can't make this call not warn, yet.
            no warnings 'once';
            @pairs = pairwise { $a . $b } @{ $opt->{fingers} }, @s;
        }

        # Print a string representation of the fret group.
        printf("%*d. %s %s\n", $n, ++$i, join(' ', @pairs), $flag)
            if !$flag || ($flag && $opt->{unplayable});
    }
}

# Assign default settings to all parameters.
sub set_defaults {

    # Intake a Go::L spec=>default hashref of settings.
    my $set = shift;

    # Set the fret range unless already given.
    # Inspect each option and add the setting if needed.
    for my $spec (keys %$set) {

        # Extract the option label from the Go::L spec.
        if ($spec =~ /^(\w+)\b.*$/) {

            # Capture label.
            my $label = $1;

            # Add the default, if not given as an argument.
            $set->{$label} = $set->{$spec} unless defined $set->{$label};
        }
    }

    # Set the range unless given.
    unless (exists $set->{range}) {

        $set->{range} = [ 1 .. $set->{max} ];

        # Prepend 0 (the open position) to the range, if requested.
        unshift @{ $set->{range} }, 0 if $set->{open};
    }

    # Inflate list(s).
    my $key = 'fingers';
    $set->{$key} = [ split /\s*[,\s]\s*/, $set->{$key} ];
}

__END__

=head1 TO DO

* span=i@ - Adjacent finger span (2 1 2)

Fingers i<->m & r<->p span 2 frets, but m<->r is only 1 in most.

* start=i - Fret start position (1)

* strings=i - Number of instrument strings (6)

* User defined rules.

=head1 AUTHOR

Gene Boggs, E<lt>gene+music@ology.netE<gt>

=head1 COPYRIGHT

Copyright 2013 Gene Boggs

=head1 LICENSE

This program is free software; you can redistribute it and/or modify it under
the terms of either: the GNU General Public License as published by the Free
Software Foundation; or the Artistic License.

See http://dev.perl.org/licenses/ for more information.

=cut

