#!/usr/bin/env perl
use strict;
use warnings;

use MIDI::Simple;
use Music::AtonalUtil;
use Text::Levenshtein qw(distance);

my $transform = shift || ''; # Can be: invert, retrograde, rotate, transpose
my $parameter = shift || 0;  # For: invert, rotate, transpose
my $distance  = shift || 0;  # Edits needed to transform subsequent phrases

my $phrase = 4;

my @notes = qw( C D E F G A B );

my @population = 0 .. @notes - 1;

my @sample;
for my $i ( 1 .. $phrase ) {
    my $selection = $population[ int rand @population ];
    push @sample, $selection;
}

my $previous = join '', @sample;

my @constrain;
for ( 1 ) {
    for my $i ( 1 .. $phrase ) {
        my $selection = $population[ int rand @population ];
        push @constrain, $selection;
    }
    my $current = join '', @constrain;
    my $d = distance( $previous, $current );
    if ( $d == $distance ) {
        @sample = ( @sample, @constrain );
    }
    else {
        @constrain = ();
        redo;
    }
}

@sample = transform( $transform, @sample ) if $transform;

my %name = int2name();
my @pitches = map { $name{$_} } @sample;

my $score = setup_midi( 1, 0, 120 );

$score->n( 'qn', $_ ) for @pitches;

$score->write_score( $0 . '.mid' );

sub transform {
    my ( $transform, @phrase ) = @_;

    my $atu = Music::AtonalUtil->new;
    my $p;
    if ( $transform eq 'invert' ) {
        $p = $atu->invert( $parameter, \@sample );
    }
    elsif ( $transform eq 'retrograde' ) {
        $p = $atu->retrograde(@sample);
    }
    elsif ( $transform eq 'rotate' ) {
        $p = $atu->rotate( $parameter, \@sample );
    }
    elsif ( $transform eq 'transpose' ) {
        $p = $atu->transpose( $parameter, \@sample );
    }

    return @phrase, @$p;
}

sub setup_midi {
    my ( $channel, $patch, $volume ) = @_;
    my $score = MIDI::Simple->new_score();
    $score->Volume($volume);
    # Lead-in
    $score->Channel(9);
    $score->n( 'qn', 42 ) for 1 .. 4;
    # Passage
    $score->Channel($channel);
    $score->patch_change( $channel, $patch );
    return $score;
}

sub int2name {
    # Convert integer pitch notation into MIDI note names
    my %name;
    my @notes = qw( C D E F G A B );
    my $int = -@notes;
    for my $octave ( 3, 4, 5, 6 ) {
        for my $note (@notes) {
            $name{$int} = $note . $octave;
#warn "N:$int $name{$int} = $note . $octave\n";
            $int++;
        }
    }
    return %name;
}
