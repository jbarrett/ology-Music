#!/usr/bin/env perl
use strict;
use warnings;

# Use local libraries
use lib map { "$ENV{HOME}/sandbox/$_/lib" } qw(
    MIDI-Util Music-ToRoman Music-Cadence Music-Duration-Partition Music-Interval-Barycentric
);
use AI::Genetic;
use List::Util qw/ uniq /;
use MIDI::Util;
use Music::Cadence;
use Music::Chord::Namer 'chordname';
use Music::Duration::Partition;
use Music::Interval::Barycentric;
use Music::Note;
use Music::Scales;

my $bpm   = shift || 120;
my $patch = shift || 4;

my $population = 50;
my $iterations = 2;

my $reps = 7; # Loop repetitions
my $max  = 50; # Number of evolved results
my $top  = 8; # Highest value of chromosome
my $base = 60; # Base of middle C MIDI values
my $size = 4; # Phrase duration size in quarter notes

my $t_octave = 5; # Treble octave
my $b_octave = 2; # Bass octave

my $sizes = { %MIDI::Simple::Length };

my @fittest = evo($max);

my $score = MIDI::Util::setup_score(bpm => $bpm, patch => $patch);

my $mc = Music::Cadence->new(octave => $t_octave);

my $count = 0;

$score->synch(
    \&fit,
    \&bass,
    \&drums,
);

$score->write_score("$0.mid");

sub fit {
    legato('wn', $fittest[0]);

    my $mdp = Music::Duration::Partition->new(
        size => $size,
        pool => [qw/ hn qn en /],
    );

    phrase($mdp, $reps, \@fittest);

    phrase($mdp, $reps, \@fittest);

    phrase($mdp, $reps, \@fittest);

    phrase($mdp, $reps, \@fittest);

    # Resolution
    $score->n('wn', 60, 64, 67); # I

    add_rest('wn');

    phrase(undef, $reps, \@fittest, 'wn');

    phrase($mdp, $reps, \@fittest);

    phrase($mdp, $reps, \@fittest);

    phrase($mdp, $reps, \@fittest);

    phrase($mdp, $reps, \@fittest);

    $score->n('wn', 60, 64, 67); # I
}

sub phrase {
    my ($mdp, $reps, $fittest, $dura) = @_;
    my $motif = $mdp ? $mdp->motif : '';
    for my $n (0 .. $reps) {
        if ($mdp) {
            legato($motif->[$n % @$motif], $fittest->[$n % @$fittest]);
        }
        else {
            legato($dura, $fittest->[$n % @$fittest]);
        }
    }
    add_cadence('wn', 1 + int rand 7);
}

sub legato {
    my ($dura, $fit) = @_;
    $score->n($dura, map { $base + $_ } @$fit);
    $count += $sizes->{$dura};
}

sub add_cadence {
    my $dura = shift || 'hn';
    my $n = shift || 1;
    my $chords = $mc->cadence(
        type    => 'half',
        leading => $n,
    );
    $score->n($dura, @$_) for @$chords;
    $count += $sizes->{$dura} * 2;'hn'
}

sub add_rest {
    my $dura = shift;
    $score->r($dura);
    $count += $sizes->{$dura};
}

sub bass {
    MIDI::Util::set_chan_patch($score, 1, 35); #42

    my @scale = get_scale_MIDI('C', $b_octave, 'pentatonic');

    $score->n('wn', $scale[0]);

    # Play and save a random note
    my @notes;
    for my $n (0 .. $reps) {
        my $note = $scale[int rand @scale];
        push @notes, $note;
        $score->n('hn', $note);
    }

    my $mdp = Music::Duration::Partition->new(
        size => $size,
        pool => [qw/ hn qn /],
    );
    my $motif = $mdp->motif;

    # Play a random note for each motif
    for my $n (0 .. 15) {
        $score->n($motif->[$n % @$motif], $scale[int rand @scale]);
    }

    # Play a random note twice in a row
    my $last;
    for my $n (0 .. $reps) {
        my $note = $scale[int rand @scale];
        $score->n('hn', $n % 2 ? $note : $last);
        $last = $note;
    }

    # Play the notes from the first loop for each motif
    for my $n (0 .. $reps) {
        $score->n($motif->[$n % @$motif], $notes[$n]);
    }

    # Resolution
    $score->n('wn', $scale[0]);

    for my $n (0 .. $reps) {
        $score->n('en', $scale[0]);
        $score->n('en', $scale[0]);
        $score->r('dhn');
    }

    # Play a random note
    for my $n (0 .. $reps) {
        $score->n('hn', $scale[int rand @scale]);
    }

    # Play a random note for each motif
    for my $n (0 .. $reps * 2 + 1) {
        $score->n($motif->[$n % @$motif], $scale[int rand @scale]);
    }

    # Play a random note twice in a row
    for my $n (0 .. $reps) {
        my $note = $scale[int rand @scale];
        $score->n('hn', $n % 2 ? $note : $last);
        $last = $note;
    }

    # Play the notes from the first loop for each motif
    for my $n (0 .. $reps) {
        $score->n($motif->[$n % @$motif], $notes[$n]);
    }

    $score->n('wn', $scale[0]);
}

sub drums {
    MIDI::Util::set_chan_patch($score, 9, 44);

    for my $duration (('qn') x ($count + 4)) {
        $score->n($duration, 44); # hi-hat
    }

    # Resolution
    $score->n('wn', 49); # crash
}

sub evo {
    my $max = shift;

    my $ga = AI::Genetic->new(
        -fitness    => \&fitness,
        -type       => 'listvector',
        -population => $population,
        -crossover  => 0.95,
        -mutation   => 0.01,
    );

    my $items = [ ([ 0 .. 11 ]) x 3 ]; # Chromatic triad
    
    $ga->init($items);
    $ga->evolve('rouletteTwoPoint', $iterations);

    my %seen;
    my @genes;
    for my $fit ($ga->getFittest($max)) {
        my @sorted = sort { $a <=> $b } @{ $fit->{GENES} };
        next if $seen{"@sorted"}++;
        push @genes, \@sorted;
    }

    my $i = 0;
    for my $fit (@genes) {
        $i++;
        my @named;
        for my $n (@$fit) {
            my $note = Music::Note->new($n + $base, 'midinum');
            push @named, $note->format('isobase');
        }
        printf "%d. [%d,%d,%d] => (%s,%s,%s) => %s\n",
            $i, @$fit, @named, scalar chordname(@named);
    }

    return @genes;
}
 
 sub fitness {
    my $chromosome = shift;

    # Chords with duplicate notes not allowed
    return 0
        if @$chromosome > uniq(@$chromosome);

    # Chords with sharps or flats not allowed
    for my $i (@$chromosome) {
        my $note = Music::Note->new($i + $base, 'midinum');
        return 0
            if $note->format('isobase') =~ /#|b/;
    }

    my $e = evenness_index($chromosome);

    return $top - $e;
}
