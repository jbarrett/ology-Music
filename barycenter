#!/usr/bin/env perl

use AI::Genetic::Pro;
use List::MoreUtils qw(uniq);
use lib $ENV{HOME} . '/sandbox/MIDI-Util/lib';
use MIDI::Util; # https://metacpan.org/release/MIDI-Util
use lib $ENV{HOME} . '/sandbox/Music-Interval-Barycentric/lib';
use Music::Interval::Barycentric; # https://metacpan.org/release/Music-Interval-Barycentric

my $bpm   = shift || 200;
my $patch = shift || 0;

my $max = 48; # Number of chords
my $threshold = 5; # Allowed top - evenness_index
my $top = 8; # Integer above the highest evenness_index
my $base = 59; # Base of middle C MIDI values
my $iter = 1; # Number of evolve iterations - XXX this appears to be broken?

my $score = MIDI::Util::setup_score(bpm => $bpm, patch => $patch);

my @fittest = evo($max);

my $count = 0;

$score->synch(
    \&fit,
    \&drums,
);

$score->write_score("$0.mid");

sub fit {
    for my $fit (@fittest[0 .. 7]) {
        legato($fit);
    }
    for my $fit (@fittest[8 .. 15]) {
        staccato($fit);
    }
    for my $fit (@fittest[16 .. 23]) {
        leading($fit);
    }
    for my $fit (@fittest[24 .. 31]) {
        legato($fit);
    }
    for my $fit (@fittest[32 .. 39]) {
        staccato($fit);
    }
    for my $fit (@fittest[40 .. 47]) {
        legato($fit);
    }

    # Resolution
    $score->n('qn', 65, 69, 72); # IV
    $score->r('qn');
    $score->n('qn', 67, 71, 74); # V
    $score->r('qn');
    $score->n('wn', 60, 64, 67); # I
}

sub drums {
    MIDI::Util::set_chan_patch($score, 9, 44);

    for my $duration (('qn') x $count) { # Measures of quarter-notes
        $score->n($duration, 44, 'm'); # hi-hat
    }

    $score->n('qn', 38, 'm'); # snare
    $score->n('qn', 35, 'm'); # kick
    $score->n('qn', 38, 'm'); # snare
    $score->n('qn', 35, 'm'); # kick
    $score->n('wn', 49, 'm'); # crash
}

sub legato {
    my ($fit) = @_;
    $score->n('qn', map { $base + $_ } @$fit);
    $score->r('qn');
    $count += 2;
}

sub staccato {
    my ($fit) = @_;
    for my $note (@$fit) {
        $score->n('sn', $base + $note);
        $score->r('sn');
        $count += 0.5;
    }
}

sub leading {
    my ($fit) = @_;
    $score->n('qn', $base + $fit->[0]);
    $score->n('qn', map { $base + $_ } @{ $fit }[1,2]);
    $count += 2;
}

sub evo {
    my $max = shift;

    my $notes = [ ([0 .. 11]) x 3 ]; # vectors of chromatc scales

    my $ga = AI::Genetic::Pro->new(        
        -fitness         => \&fitness,     # fitness function
        -terminate       => \&terminate,   # terminate function
        -type            => 'listvector',  # type of chromosome
        -population      => 100,           # population
        -crossover       => 0.9,           # probab. of crossover
        -mutation        => 0.5,           # probab. of mutation
        -parents         => 2,             # number  of parents
        -selection       => ['Roulette'],  # selection strategy
        -strategy        => ['PMX'],       # crossover strategy
        -cache           => 1,             # cache results
        -history         => 1,             # remember best results
        -preserve        => 1,             # remember the bests
        -variable_length => 0,             # turn variable length OFF
    );

    $ga->init($notes);
    $ga->evolve($iter);

    my @genes;
    for my $chromosome (reverse $ga->getFittest($max)) {
        push @genes, get_chromosome($ga, $chromosome);
    }

    return @genes;
}

# "The higher the value, the [greater] the chance of an individual passing its genes on in future generations through mating (crossover)."
sub fitness {
    my ($ga, $chromosome) = @_;

    $chromosome = get_chromosome($ga, $chromosome);

    return 0
        if @$chromosome > uniq(@$chromosome); # Duplicates not allowed

    # Chords with adjacent half-steps are not allowed
    for my $i (@$chromosome) {
        for my $j (@$chromosome) {
            return 0
                if ($j == $i + 1) || ($j == $i - 1);
        }
    }

    return $top - evenness_index($chromosome); # "Even" chords are deemed fittest
}

# Stop evolving if above the threshold
sub terminate {
    my ($ga) = @_;
    return $ga->as_value($ga->getFittest) >= $threshold ? 1 : 0;
}

sub get_chromosome {
    my ($ga, $chromosome) = @_;
    $chromosome ||= $ga->getFittest;
    return [ split /_+/, $ga->as_string($chromosome) ];
}
