#!/usr/bin/perl

our $VERSION = '0.13';

use strict;
use warnings;

use Algorithm::Combinatorics qw( variations_with_repetition );
use Getopt::Long;
use Getopt::Simple qw( $switch );
use List::AllUtils qw( pairwise sum );
use Pod::Usage;

use constant BACKWARD_INFRACTION => 'B';
use constant OVERLAP_INFRACTION  => 'O';
use constant SPAN_INFRACTION     => 'S';

=head1 NAME

fretting - Stringed musical instrument fretboard positions

=head1 DESCRIPTION

Show all possible stringed musical instrument fretboard positions.

With the L</ARGUMENTS>, you can define fret group sizes, the number (and names)
of available fingers.  Also, you can show unplayable fingerings and the reasons:
B<B>ackwards or reverse fingering, finger B<S>pan impossibilities and barre
finger overlaps.  Also, the "open position" and "finger muting" can be shown.

The symbols for the fingers are from Spanish (de Flamenco).

  index  : índice  (i)
  middle : medular (m)
  ring   : anular  (a)
  little : meñeque (q)
  thumb  : pulgar  (p)

There are a few special cases that are handled by the L</infraction> routine.
Specifically the middle and ring fingers cannot span more than a fret
comfortably.  Also, certain "backwards" fret positions cannot physically be
played.  Also, the thumb can only play or mute the leftmost fret (which
corresponds to the bottom string of an instrument) and mute the "2nd left-most."

Only the max setting is required, but all the defaults are used unless given.

=head1 SYNOPSIS

 $ perl fretting [--help|-h|--docs|-d]
 $ perl fretting --debug \
    --sfr=1 --nfr=4 \
    --fin="i m r p t" --sfi=0 --nfi=4 \
    --str="E A D G B E'" --sst=2 --nst=4 --open \
    --unplayable --accumulate

=head2 ARGUMENTS

 Ex: --arg : Description = Default setting

 --help       : This exciting help message!
 --docs       : The full documentation
 --version    : Program version
 --debug      : Show progress        = 0
 --sfret      : Starting fret        = 1
 --nfret      : Number of frets      = 4
 --fingers    : Finger symbols       = i m a q p
 --sfinger    : Starting finger      = 0
 --nfinger    : Number of fingers    = 4
 --strings    : String symbols       = e a d g b e'
 --sstring    : Starting string      = 2
 --nstring    : Number of strings    = 4
 --open       : Use the open string  = 0
 --mute       : Use muted strings    = 0
 --unplayable : Unplayable positions = 0
 --accumulate : Show all infractions = 0

=cut

# Default, initial parameters.
my $setting = {
    sfret      => { type => '=i', default => 1 },
    nfret      => { type => '=i', default => 4 },
    fingers    => { type => '=s', default => q/i m a q p/ },
    fspan      => { type => '=s', default => q/2 1 2/ },
    sfinger    => { type => '=i', default => 0 },
    nfinger    => { type => '=i', default => 4 },
    strings    => { type => '=s', default => q/e a d g b e'/ },
    sstring    => { type => '=i', default => 2 },
    nstring    => { type => '=i', default => 4 },
    open       => { type => '',   default => 0 },
    mute       => { type => '',   default => 0 },
    barre      => { type => '',   default => 0 },
    docs       => { type => '',   default => 0 },
    debug      => { type => '',   default => 0 },
    indexes    => { type => '',   default => 0 },
    unplayable => { type => '',   default => 0 },
    accumulate => { type => '',   default => 0 },
};

# See warnings in output context.
$|++;

# Get the command line arguments and specify doc level.
setup($setting, @ARGV); # NOTE: This populates the $switch global hashref.

# Transform space-separated lists into proper arrays.
transform($switch);

# Set the fret range.
set_range($switch);

# Fingers are 1 based. 0 means no finger, handled by --open & --muted.
my @indexes = 1 .. @{ $switch->{fingers} };
# Make a finger=>number association.
$switch->{indexes} = {
    pairwise { ($a => $b) } @{ $switch->{fingers} }, @indexes
};

# Fret groups per finger.
my $v = variations_with_repetition($switch->{range}, $switch->{nfinger});

# Line number format width. # TODO Compute instead of hard-coding.
# Loop counter for each fret group shown in the final output.
my ($width, $i) = (3, 0);

# Increment our counter unless --open or -muted are given.
$i++ unless $switch->{open} || $switch->{mute};

# Inspect each position AKA fret group.
while (my $position = $v->next) {

    # Flag unplayable fret groups.
    my @flags = infraction($switch, $position);

    # Change zeros to x's if --muted
    if ($switch->{mute}) {
        @$position = map { $_ ? $_ : 'x' } @$position;
    }

    # Interleave space-separated lists.
    my @pairs = pairs($switch->{fingers}, $position);
#    @pairs = pairs($switch->{strings}, \@pairs);

    # Print a string representation of the fret group.
    printf("%*d. %s %s\n",
        $width, $i++,
        join(' ', @pairs),
        (@flags ? '-' . join(',', @flags) : '')
    ) if !@flags || $switch->{unplayable};
}

sub setup { # Harvest command-line arguments and use magical POD.

    # Intake a Go::L spec=>default hashref of settings.
    my ($set, @args) = @_;

    # Auto-help if we are called with no arguments.
    pod2usage(-verbose => 1) unless @args;

    # Set handy auto-documentation features.
    Getopt::Long::Configure(qw( auto_version auto_help ));

    # Collect the command-line arguments.
    my $options = Getopt::Simple->new;
    # NOTE: Populates global switch variable.
    $options->getOptions($set) || pod2usage(-verbose => 0);

    # Show documentation if requested.
    pod2usage(-verbose => 1) if $switch->{help};
    pod2usage(-verbose => 2) if $switch->{docs};
}

sub pairs { # Interleave two arrayrefs.
    my ($A, $B) = @_;

    if (@$A > @$B) {
        @$A = @$A[ 0 .. @$B - 1];
    }
    elsif (@$B > @$A) {
        @$B = @$B[ 0 .. @$A - 1];
    }

    # Return the (possibly single) pairs, in a width of 2 columns.
    return pairwise { sprintf '%2s', $b ? $a . $b : $b } @$A, @$B;
}

sub transform { # Transform space-separated lists into proper arrays.

    # Pass-in settings.
    my $set = shift;

    # Traverse the settings.
    for my $option (keys %$set) {

        # If the setting contains a space character...
        if ($set->{$option} =~ /\s/) {

            # Split the setting by whitespace.
            $set->{$option} = [ split /\s+/, $set->{$option} ];
        }
    }
}

sub set_range { # Define the fret range.

    # Pass-in settings.
    my $set = shift;

    # Set the fret range.
    my @range = ($set->{sfret} .. $set->{sfret} + $set->{nfret} - 1);

    # Prepend zero if requested.
    unshift @range, 0 if $set->{open};

    # Add the range to the settings.
    $set->{range} = \@range;
}

sub infraction { # Flag unplayable fingerings.

    # The settings and position to consider.
    my ($set, $pos) = @_;

    # Declare the flag to return.
    # " a holder for the last seen position.
    # " a finger counter.
    # Declare the "too wide" span offset.
    my ($flag, $previous, $count, $span) = ([], undef, 0, 2);

    # Declare a bucket to keep track of fingers and their fret positions.
    my $track = {};

    # Inspect pairs of the position.
    # This is referred to by `last` unless we are accumulating.
    FLAG: for my $current (@$pos) {

        # TODO Flag if thumb plays any but the bottom or mutes the next.

        # Set the first item of the pair and move on.
        if (not defined $previous) {
            $previous = $current;
            next;
        }

        # Increment the finger counter.
        $count++;

        # Skip pairs with zeros i.e. the 0th fret i.e. an open string.
        if ($current && $previous) {

            # Set the previous and current fingers.
            my $seen   = $count ? $set->{fingers}[$count - 1] : '?';
            my $finger = $set->{fingers}[$count] || '?';

            # Set the current finger index.
            my $fidx = $set->{indexes}{$finger};

            # Keep track of the fingers and their frets.
            $track->{$seen}   = $previous unless exists $track->{$seen};
            $track->{$finger} = $current  unless exists $track->{$finger};

            # Show our progress if requested.
            if ($set->{debug}) {

                warn sprintf "Finger: %s(%d) %s(%d)\nFret:%6d%5d\n",
                    $seen, $track->{$seen},
                    $finger, $track->{$finger},
                    $previous, $current;
            }

            # Rule: Overlapping frets are not allowed.
            if ($set->{barre} && $previous == $current) {

                # Flag the given type of infraction.
                push @$flag, OVERLAP_INFRACTION;

                # Skip to the next position unless we are accumulating.
                last FLAG unless $set->{accumulate};
            }

            # Collect the fingers that have already been seen.
            my @seen = grep { exists $track->{$_} }
                @{ $set->{fingers} }[ 0 .. $set->{indexes}{$seen} - 1 ];

            # Loop over the seen fingers.
            for my $s (@seen) {

                # Set the index of the current seen finger.
                my $sidx = $set->{indexes}{$s};

                # Rule: Lower fingers on higher frets are not allowed.
                #       Higher fingers on lower "
                if (($track->{$s} > $current && $sidx <= $fidx)
                    ||
                    ($track->{$s} < $current && $sidx >= $fidx)
                ) {

                    # Flag the given type of infraction.
                    push @$flag, BACKWARD_INFRACTION;

                    # Skip to the next position unless we are accumulating.
                    last FLAG unless $set->{accumulate};
                }

                # Compute span metrics.
                my $fret_span = abs($current - $track->{$s});
                my $sum = sum_span($sidx - 1, $fidx - 1, @{ $set->{fspan} });

                # Rule: Frets can't be more than the allowed finger span.
                if ($sidx != $fidx && $fret_span > $sum) {

                    # Flag the given type of infraction.
                    push @$flag, SPAN_INFRACTION;

                    # Skip to the next position unless we are accumulating.
                    last FLAG unless $set->{accumulate};
                }
            }
        }

        # Update the previously seen item.
        $previous = $current;
    }

    # Return the list of infractions found.
    return @$flag;
}

sub sum_span { # Return the sum of the bounded list.

    # Get the list and bounds from the call.
    my ($x, $y, @list) = @_;

    # Restrict the list by the bounds.
    my @new = @list[ $x > $y ? ($y .. $x - 1) : ($x .. $y - 1) ];

    # Return the list sum based on the relative sizes of x and y.
    return sum(@new);
}

__END__

=head1 AUTHOR

Gene Boggs, E<lt>gene+music@ology.netE<gt>

=head1 COPYRIGHT

Copyright 2013 Gene Boggs

=head1 LICENSE

This program is free software; you can redistribute it and/or modify it under
the terms of either: the GNU General Public License as published by the Free
Software Foundation; or the Artistic License.

See http://dev.perl.org/licenses/ for more information.

=cut
