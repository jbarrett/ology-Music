#!/usr/bin/env perl
use strict;
use warnings;

use lib '/Users/gene/sandbox/MIDI-Util/lib';
use MIDI::Util;
use lib '/Users/gene/sandbox/Music-ScaleNote/lib';
use Music::ScaleNote;
use Music::Chord::Namer qw/ chordname /;

my $max = shift || 4;

my @tnotes = qw( C4 E4 G4 );
my $bnote  = 'C3';
my @bnotes;

my $trebp = 0; # Treble patch
my $bassp = 42; # Bass patch

my $half   = 'hn';
my $whole  = 'wn';
my $dwhole = 'dwn';

my $score = MIDI::Util::setup_score( lead_in => 0, bpm => 20 );

# Instantiate a scale-note manipulator
my $msn = Music::ScaleNote->new(
    scale_note  => 'C',
    scale_name  => 'pmajor',
    note_format => 'ISO',
#    verbose     => 1,
);

my $i = 0; # Chord counter

$score->synch(
    \&top,
    \&bottom,
);

$score->write_score("$0.mid");

sub top {
    MIDI::Util::set_chan_patch( $score, 0, $trebp );

    my @chord = @tnotes;

    for ( 1 .. $max ) {
        $i++;

        # Return to the initial chord
#        @chord = @tnotes unless $i % 4;

        # Find the likely chord name
        my @notes = @chord;
        for ( @notes ) {
            $_ =~ s/\d//g;
        }
        warn "$i. Chord: @notes = " . chordname(@notes), "\n";

        # Update the bass notes with the bottom-most note of the chord
        push @bnotes, $notes[0] . 3;

        # Add the note and a rest to the score
        $score->n( $whole, @chord );
        $score->r($half);

        # Mutate the chord!
        @chord = mutate( $msn, 4, 5, @chord );
    }

    # Add the initial chord to the end of the score
    $score->n( $whole, @tnotes );
    push @bnotes, $bnote;
}

sub mutate {
    my ( $msn, $lowerb, $upperb, @chord ) = @_;

    # Get two of the chord notes to change
    my $roll1 = $chord[ int rand @chord ];
    my $roll2 = $chord[ int rand @chord ];

    my @mutated;

    # For each note of the chord...
    for my $n ( @chord ) {
        # If it is one of the two changes...
        if ( $n eq $roll1 || $n eq $roll2 ) {
            ( my $octave = $n ) =~ s/^.+(-?\d+)$/$1/;

            my $note;

            # Get a new note within the lower and upper bounds
            while ( !$note || $octave < $lowerb || $octave > $upperb ) {
                $note = $msn->get_offset(
                    note_name => $n,
                    offset    => $octave < $lowerb ? 1 : $octave > $upperb ? -1 : int rand 2 ? 1 : -1,
                );
                $n = $note->format('ISO');

                # Get the octave to determine if we need to loop again
                ( $octave = $n ) =~ s/^.+(-?\d+)$/$1/;
            }

            # Convert the ISO note format to a MIDI-note-string
            $n =~ s/#/s/;
            $n =~ s/b/f/;
        }

        push @mutated, $n;
    }

    return @mutated;
}

sub bottom {
    MIDI::Util::set_chan_patch( $score, 1, $bassp );
#    $score->Volume(90);

    # Add each bass note to the score
    for my $note ( @bnotes ) {
        $score->n( $whole, $note );
        $score->r($half);
    }
}
