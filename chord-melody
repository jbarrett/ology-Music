#!/usr/bin/env perl
use strict;
use warnings;

use Data::Dumper::Compact qw(ddc);
use lib map { "$ENV{HOME}/sandbox/$_/lib" } qw(MIDI-Util Music-Chord-Progression Music-MelodicDevice-Inversion Music-MelodicDevice-Ornamentation Music-ToRoman);
use MIDI::Util;
use Music::Chord::Progression;
use Music::MelodicDevice::Inversion;
use Music::MelodicDevice::Ornamentation;
use Music::Note;
use Music::Scales qw(get_scale_MIDI);
use Music::ToRoman;
use Music::VoiceGen;

my $max_phrase = shift || 28;
my $num_notes  = shift || 4;
my $scale_note = shift || 'C';
my $scale_name = shift || 'major';
my $bscale     = shift || 'pentatonic';

my $score = MIDI::Util::setup_score();

$score->synch(
    \&progression,
    \&melody,
);

$score->write_score("$0.mid");

sub melody {
    MIDI::Util::set_chan_patch($score, 0, 0);

    my $mdi = Music::MelodicDevice::Inversion->new(
        scale_note => $scale_note,
        scale_name => $bscale,
#        verbose => 1,
    );

    my $mdo = Music::MelodicDevice::Ornamentation->new(
        scale_note => $scale_note,
        scale_name => $bscale,
#        verbose => 1,
    );

    my @pitches = get_scale_MIDI($scale_note, 5, $bscale);
    my @intervals = qw(-4 -3 -2 -1 1 2 3 4);
    my $voice = Music::VoiceGen->new(
        pitches   => \@pitches,
        intervals => \@intervals,
    );

    my @notes;

    for my $i (1 .. $max_phrase) {
        my @spec;

        if ($i % 2 == 0) {
            @notes = @{ $mdi->invert($notes[0], \@notes) };
            for my $n (0 .. $#notes) {
                if ($n > 0 && $n % 3 == 0) {
                    my $roll = int rand 5;
                    if ($roll == 0) {
                        print "Ornament: trill\n";
                        push @spec, @{ $mdo->trill('qn', $notes[$n], 2, 1) };
                    }
                    elsif ($roll == 1) {
                        print "Ornament: mordent\n";
                        push @spec, @{ $mdo->mordent('qn', $notes[$n], 1) };
                    }
                    elsif ($roll == 2) {
                        print "Ornament: turn\n";
                        push @spec, @{ $mdo->turn('qn', $notes[$n], 1) };
                    }
                    else {
                        push @spec, [ 'qn', $notes[$n] ];
                    }
                }
                else {
                    push @spec, [ 'qn', $notes[$n] ];
                }
            }
        }
        else {
            @notes = map { Music::Note->new($voice->rand, 'midinum')->format('ISO') } 1 .. $num_notes;
            @spec = map { [ 'qn', $_ ] } @notes;
        }

        @spec = map { [ MIDI::Util::midi_format(@$_) ] } @spec;
#        print 'Spec: ', ddc(\@spec);

        $score->n(@$_) for @spec;
    }
}

sub progression {
    MIDI::Util::set_chan_patch($score, 1, 0);

    my $mtr = Music::ToRoman->new(
        scale_note => $scale_note,
        scale_name => $scale_name,
        chords     => 0,
#        verbose    => 1,
    );

    my @pitches = get_scale_MIDI($scale_note, 4, $scale_name);
    my @intervals = qw(-4 -3 -2 -1 1 2 3 4);
    my $voice = Music::VoiceGen->new(
        pitches   => \@pitches,
        intervals => \@intervals,
    );
    my @notes = map { Music::Note->new($voice->rand, 'midinum')->format('isobase') } 1 .. 4;

    for my $n (@notes) {
        my $roman = $mtr->parse($n);
        my $name;
        my $chords;
        if ($roman =~ /^[A-Z]+$/) {
            $name = 'major';
            $chords = ['','m','m','','','m','dim'];
        }
        else {
            $name = 'minor';
            $chords = ['m','dim','','m','m','',''];
        }

        my $prog = Music::Chord::Progression->new(
            scale_note => $n,
            scale_name => $name,
            chord_map  => $chords,
            resolve    => 0,
#            substitute => 1,
#            verbose    => 1,
        );
        my $notes = $prog->generate;

        for my $chord (@$notes) {
            $chord = [ MIDI::Util::midi_format(@$chord) ];
            $score->n('wn', @$chord);
        }
        print "$n ($roman): ", ddc($notes);
    }
}
