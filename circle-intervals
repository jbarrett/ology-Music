#!/usr/bin/env perl
use strict;
use warnings;

# Evenly space a number of named sub-circles around a circle.
# Optionally show an inner circle of offset notes.
# Examples:
# Chromatic: perl circle-intervals 1 24 1 > circle-intervals.svg
# Circle of fifths: perl circle-intervals 5 12 0 1 > circle-intervals.svg
# Numeric: perl circle-intervals 5 12 0 1 512 C C\# 1 > circle-intervals.svg
#    "   : perl circle-intervals 3 16 1 1 512 C C\# 1 > circle-intervals.svg
# Coltrane's wholetone: perl circle-intervals 2 30 1 1 > circle-intervals.svg

use List::SomeUtils qw(first_index);
use Math::Trig ();
use Music::Scales qw(get_scale_notes);
use SVG qw(title);

use constant PI     => 2 * atan2(1,0);
use constant HALF   => PI / 2;
use constant DOUBLE => 2 * PI;
use constant SCALE  => 'chromatic';

my $interval   = shift || 1;    # interval to calculate: default chromatic 1-11
my $show_marks = shift || 12;   # how many circular note marks to display 2-60
my $show_inner = shift // 0;    # show the inner ring?
my $flat       = shift // 0;    # show note names with flats: default sharps
my $diameter   = shift || 512;  # the diameter of the circle
my $outer_note = shift || 'C';  # starting outer ring note
my $inner_note = shift || 'C#'; # starting inner ring note
my $numeric    = shift // 0;

my $knowns      = 11;           # known intervals 1-11
my $total_marks = 60;           # maximum number of interval markers 2-60
my $border_size = 10;           # chart margin
my $sub_radius  = 11;           # radius for sub-circle markings
my $radius      = $diameter / 2;
my $frame_size  = $diameter + 2 * $border_size;

my @outer_scale = get_scale_notes($outer_note, SCALE, undef, $flat ? 'b' : '#');

my @outer_labels = map { $outer_scale[ (($_ - 1) * $interval) % @outer_scale ] }
    1 .. $show_marks;

my $svg = SVG->new(
    width  => $frame_size,
    height => $frame_size,
);
$svg->title()->cdata("Show $show_marks marks around a circle");

# generate a group element
my $outer_style = $svg->group(
    id    => 'outer-style-group',
    style => {
        stroke => 'green',
        fill   => 'white',
    },
);

$outer_style->circle(
    cx => $frame_size / 2,
    cy => $frame_size / 2,
    r  => $radius,
    id => 'style-group-outer-circle',
);

$outer_style->text(
    id     => 'style-group-outer-info',
    x      => $frame_size / 2 - $sub_radius * 4,
    y      => $frame_size / 2,
    style => {
        stroke => 'gray',
    },
    -cdata => "Interval: $interval, Marks: $show_marks",
);

my $i = 0;

# compute the ring positions
my @marks = map { $_ * $total_marks / $show_marks } 1 .. $show_marks;

# display the ring positions
for my $mark (@marks) {
    $i++;

    my $p = coordinate($mark, $total_marks, $radius);

    $outer_style->circle(
        id => $mark . '-style-group-outer-sub-circle',
        cx => $p->[0] + $sub_radius,
        cy => $p->[1] + $sub_radius,
        r  => $sub_radius,
    );

    my $item = $outer_labels[ $i % @outer_labels ];
    my $text = $numeric
        ? first_index { $_ eq $item } @outer_scale
        : $item;
    $outer_style->text(
        id     => $i . '-style-group-outer-sub-text',
        x      => $p->[0] + $sub_radius - ($sub_radius / 2),
        y      => $p->[1] + $sub_radius + ($sub_radius / 2),
        -cdata => $text,
    );
}

if ($show_inner) {
    my $inner_style = $svg->group(
        id    => 'inner-style-group',
        style => {
            stroke => 'gray',
            fill   => 'white',
        },
    );

    # adjust the inner ring with these rotations
    my @factors = (
        0, 0,
        1.7,  1.2,  0.9,  0.7,
        0.65, 0.6,  0.5,  0.45,
        0.45, 0.4,  0.35, 0.35,
        0.35, 0.35, 0.35, 0.3,
        0.3,  0.25, 0.25, 0.25,
        0.25, 0.25, 0.25, 0.24,
        0.24, 0.23, 0.22, 0.22,
        0.22, 0.22, 0.21, 0.21,
        0.2,  0.2,  0.2,  0.2,
        0.2,  0.2,  0.2,  0.2,
        0.19, 0.19, 0.19, 0.19,
        0.19, 0.19, 0.18, 0.18,
        0.18, 0.18, 0.18, 0.18,
        0.18, 0.18, 0.18, 0.18,
        0.18, 0.18, 0.17,
    );
    my %intervals;
    for my $major (1 .. $knowns) {
        for my $minor (2 .. $total_marks) {
            $intervals{ $major . ',' . $minor } = $factors[$minor];
        }
    }

    my @inner_scale = get_scale_notes($inner_note, SCALE, undef, $flat ? 'b' : '#');

    my @inner_labels = map { $inner_scale[ (($_ - 1) * $interval) % @inner_scale ] }
        1 .. $show_marks;

    my $inner_radius = $radius - $sub_radius * 3;

    $inner_style->circle(
        id => 'style-group-inner-circle',
        cx => $frame_size / 2,
        cy => $frame_size / 2,
        r  => $inner_radius,
    );

    $inner_style->text(
        id     => 'style-group-inner-info',
        x      => $frame_size / 2 - $sub_radius * 4,
        y      => $frame_size / 2,
        -cdata => "Interval: $interval, Marks: $show_marks",
    );

    $i = 0;

    for my $mark (@marks) {
        $i++;

        my $p = coordinate(
            $mark,
            $total_marks,
            $inner_radius,
            $intervals{ $interval . ',' . $show_marks }
        );

        $inner_style->circle(
            id => $mark . '-style-group-inner-sub-circle',
            cx => $p->[0] + $sub_radius * 4,
            cy => $p->[1] + $sub_radius * 4,
            r  => $sub_radius,
        );

        my $item = $inner_labels[ $i % @inner_labels ];
        my $text = $numeric
            ? first_index { $_ eq $item } @inner_scale
            : $item;
        $inner_style->text(
            id     => $i . '-style-group-inner-sub-text',
            x      => $p->[0] + $sub_radius * 3 + 3,
            y      => $p->[1] + $sub_radius * 3 + 3 + $sub_radius,
            -cdata => $text,
        );
    }
}

print $svg->xmlify;

sub coordinate {
    my ($p, $total, $radius, $inner) = @_;

    # Compute the analog minute time equivalent
    my $analog = $p / $total * DOUBLE - HALF;

    # Replace the time value with the polar coordinate
    my $coord;
    if ($inner) {
        $coord = [
            $radius + $radius * cos($analog - DOUBLE / $total + $inner),
            $radius + $radius * sin($analog - DOUBLE / $total + $inner)
        ];
    }
    else {
        $coord = [
            $radius + $radius * cos($analog),
            $radius + $radius * sin($analog)
        ];
    }

    return $coord;
}
