#!/usr/bin/env perl
use strict;
use warnings;

# Evenly space a number of named sub-circles around a circle.
# Optionally show an inner circle of offset notes.

use Data::Dumper::Compact qw(ddc);
use Math::Trig ();
use Music::Scales qw(get_scale_notes);
use SVG qw(title);

use constant PI     => 2 * atan2(1,0);
use constant HALF   => PI / 2;
use constant DOUBLE => 2 * PI;

my $interval   = shift || 1;    # interval to calculate: default chromatic
my $show_marks = shift || 12;   # how many circular note marks to display
my $show_inner = shift // 0;    # show we show the inner ring?
my $flat       = shift // 0;    # show note names with flats: default sharps
my $diameter   = shift || 512;  # the diameter of the circle

my $knowns      = 5;            # known intervals 1-5
my $total_marks = 60;           # maximum number of interval markers
my $border_size = 10;           # chart margin
my $sub_radius  = 11;           # radius for sub-circle markings
my $radius      = $diameter / 2;
my $frame_size  = $diameter + 2 * $border_size;

my @outer_scale = get_scale_notes('C', 'chromatic', undef, $flat ? 'b' : '#');

my @outer_labels = map { $outer_scale[ (($_ - 1) * $interval) % @outer_scale ] }
    1 .. $show_marks;

my $svg = SVG->new(
    width  => $frame_size,
    height => $frame_size,
);
$svg->title()->cdata("Show $show_marks marks around a circle");

# generate a group element
my $style = $svg->group(
    id    => 'style-group',
    style => {
        stroke => 'gray',
        fill   => 'white',
    },
);

$style->circle(
    cx => $frame_size / 2,
    cy => $frame_size / 2,
    r  => $radius,
    id => 'style-group-outer-circle',
);

my $i = 0;

my @marks = map { $_ * $total_marks / $show_marks } 1 .. $show_marks;

for my $mark (@marks) {
    $i++;

    my $p = time_point($mark, $total_marks, $radius);

    $style->circle(
        id => $mark . '-style-group-outer-sub-circle',
        cx => $p->[0] + $sub_radius,
        cy => $p->[1] + $sub_radius,
        r  => $sub_radius,
    );
    $style->text(
        id     => $i . '-style-group-outer-sub-text',
        x      => $p->[0] + $sub_radius - ($sub_radius / 2),
        y      => $p->[1] + $sub_radius + ($sub_radius / 2),
        -cdata => $outer_labels[ $i % @outer_labels ],
    );
}

if ($show_inner) {
    # adjust the inner ring
    my @factors = (
        0, 0,
        1.7,  1.2,  0.9,  0.7,
        0.65, 0.6,  0.5,  0.45,
        0.45, 0.4,  0.35, 0.35,
        0.35, 0.35, 0.35, 0.3,
        0.3,  0.25, 0.25, 0.25,
        0.25, 0.25, 0.25, 0.24,
        0.24, 0.23, 0.22, 0.22,
        0.22, 0.22, 0.21, 0.21,
        0.2,  0.2,  0.2,  0.2,
        0.2,  0.2,  0.2,  0.2,
        0.19, 0.19, 0.19, 0.19,
        0.19, 0.19, 0.18, 0.18,
        0.18, 0.18, 0.18, 0.18,
        0.18, 0.18, 0.18, 0.18,
        0.18, 0.18, 0.17,
    );
    my %intervals;
    for my $major (1 .. $knowns) {
        for my $minor (2 .. $total_marks) {
            $intervals{ $major . ',' . $minor } = $factors[$minor];
        }
    }

    my @inner_scale = get_scale_notes('C#', 'chromatic', undef, $flat ? 'b' : '#');

    my @inner_labels = map { $inner_scale[ (($_ - 1) * $interval) % @inner_scale ] }
        1 .. $show_marks;

    $style->circle(
        cx => $frame_size / 2,
        cy => $frame_size / 2,
        r  => $radius - $sub_radius * 3,
        id => 'style-group-inner-circle',
    );

    $i = 0;

    for my $mark (@marks) {
        $i++;

        my $p = time_point(
            $mark,
            $total_marks,
            $radius - $sub_radius * 3,
            $intervals{ $interval . ',' . $show_marks }
        );

        $style->circle(
            id => $mark . '-style-group-inner-sub-circle',
            cx => $p->[0] + $sub_radius * 4,
            cy => $p->[1] + $sub_radius * 4,
            r  => $sub_radius,
        );
        $style->text(
            id     => $i . '-style-group-inner-sub-text',
            x      => $p->[0] + $sub_radius * 3 + 3,
            y      => $p->[1] + $sub_radius * 3 + $sub_radius + 3,
            -cdata => $inner_labels[ $i % @inner_labels ],
        );
    }
}

print $svg->xmlify;

sub time_point {
    my ($p, $total, $radius, $inner) = @_;

    # Compute the analog minute time equivalent
    my $analog = $p / $total * DOUBLE - HALF;

    # Replace the time value with the polar coordinate
    my $coord;
    if ($inner) {
        $coord = [
            $radius + $radius * cos($analog - DOUBLE / $total + $inner),
            $radius + $radius * sin($analog - DOUBLE / $total + $inner)
        ];
    }
    else {
        $coord = [
            $radius + $radius * cos($analog),
            $radius + $radius * sin($analog)
        ];
    }

    return $coord;
}
