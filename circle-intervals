#!/usr/bin/env perl
use strict;
use warnings;

# Evenly space a number of named sub-circles around a circle.
# Optionally show an inner circle of offset notes.
# Examples:
# Chromatic: perl circle-intervals 1 24 1 > circle-intervals.svg
# Circle of 5ths: perl circle-intervals 5 12 > circle-intervals.svg
#    "          : perl circle-intervals 7 12 1 0 512 C F > circle-intervals.svg
# Numeric: perl circle-intervals 5 12 0 0 512 C C\# 1 > circle-intervals.svg
#    "   : perl circle-intervals 3 16 1 0 512 C C\# 1 > circle-intervals.svg
# Coltrane's wholetone: perl circle-intervals 2 30 1 1 > circle-intervals.svg

use List::SomeUtils qw(first_index);
use Math::Trig ();
use Music::Scales qw(get_scale_notes);
use SVG qw(title);

use constant PI     => 2 * atan2(1,0);
use constant HALF   => PI / 2;
use constant DOUBLE => 2 * PI;
use constant SCALE  => 'chromatic';

my $interval   = shift || 1;    # interval to calculate: default chromatic 1-11
my $show_marks = shift || 12;   # how many circular note marks to display 2-60
my $show_inner = shift // 0;    # show the inner ring?
my $flat       = shift // 0;    # show note names with flats: default sharps
my $diameter   = shift || 512;  # the diameter of the circle
my $outer_note = shift || 'C';  # starting outer ring note
my $inner_note = shift || 'C#'; # starting inner ring note
my $numeric    = shift // 0;    # display notes as pitch numbers
my $outer_line = shift || 'green';
my $outer_fill = shift || 'white';
my $inner_line = shift || 'gray';
my $inner_fill = shift || 'white';
my $text_line  = shift || 'black';

my $font_size   = 20;           # size of the center info font
my $knowns      = 11;           # known intervals 1-11
my $total_marks = 60;           # maximum number of interval markers 2-60
my $border_size = 10;           # chart margin
my $sub_radius  = 11;           # radius for sub-circle markings
my $radius      = $diameter / 2;
my $frame_size  = $diameter + 2 * $border_size;
my %named       = (
    1  => 'halfstep',
    2  => 'wholestep',
    3  => 'min 3rd',
    4  => 'maj 3rd',
    5  => 'perf 4th',
    6  => 'tritone',
    7  => 'perf 5th',
    8  => 'sharp 5',
    9  => 'sixth',
    10 => 'flat 7',
    11 => 'seventh',
);

my @outer_scale = get_scale_notes($outer_note, SCALE, undef, $flat ? 'b' : '#');

my @outer_labels = get_labels(\@outer_scale, $interval, $show_marks);

my $svg = SVG->new(
    width  => $frame_size,
    height => $frame_size,
);
$svg->title()->cdata("Show $show_marks marks around a note circle for the $named{$interval} interval");

# generate a group element
my $outer_style = $svg->group(
    id    => 'outer-style-group',
    style => {
        stroke => $outer_line,
        fill   => $outer_fill,
    },
);

$outer_style->circle(
    cx => $frame_size / 2,
    cy => $frame_size / 2,
    r  => $radius,
    id => 'style-group-outer-circle',
);

$outer_style->text(
    id    => 'style-group-outer-info',
    x     => $frame_size / 2 - $sub_radius * 9,
    y     => $frame_size / 2,
    style => {
        stroke      => $text_line,
        'font-size' => $font_size,
    },
    -cdata => "Interval: $named{$interval}, Notes: $show_marks",
) if !$show_inner;

my $i = 0;

# compute the ring positions
my @marks = map { $_ * $total_marks / $show_marks } 1 .. $show_marks;

# display the ring positions
for my $mark (@marks) {
    $i++;

    my $p = coordinate($mark, $total_marks, $radius);

    $outer_style->circle(
        id => $mark . '-style-group-outer-sub-circle',
        cx => $p->[0] + $sub_radius,
        cy => $p->[1] + $sub_radius,
        r  => $sub_radius,
    );

    my $item = $outer_labels[ $i % @outer_labels ];
    my $text = $numeric
        ? first_index { $_ eq $item } @outer_scale
        : $item;
    $outer_style->text(
        id     => $i . '-style-group-outer-sub-text',
        x      => $p->[0] + $sub_radius - ($sub_radius / 2),
        y      => $p->[1] + $sub_radius + ($sub_radius / 2),
        -cdata => $text,
    );
}

if ($show_inner) {
    my $inner_style = $svg->group(
        id    => 'inner-style-group',
        style => {
            stroke => $inner_line,
            fill   => $inner_fill,
        },
    );

    # adjust the inner ring with these rotations
    my @factors = (
        0,    0,
        1.7,  1.2,  0.9,  0.7,
        0.65, 0.6,  0.5,  0.45,
        0.45, 0.4,  0.35, 0.35,
        0.35, 0.35, 0.35, 0.3,
        0.3,  0.25, 0.25, 0.25,
        0.25, 0.25, 0.25, 0.24,
        0.24, 0.23, 0.22, 0.22,
        0.22, 0.22, 0.21, 0.21,
        0.2,  0.2,  0.2,  0.2,
        0.2,  0.2,  0.2,  0.2,
        0.19, 0.19, 0.19, 0.19,
        0.19, 0.19, 0.18, 0.18,
        0.18, 0.18, 0.18, 0.18,
        0.18, 0.18, 0.18, 0.18,
        0.18, 0.18, 0.17,
    );
    my %intervals;
    for my $known (1 .. $knowns) {
        for my $mark (2 .. $total_marks) {
            $intervals{ $known . ',' . $mark } = $factors[$mark];
        }
    }

    my @inner_scale = get_scale_notes($inner_note, SCALE, undef, $flat ? 'b' : '#');

    my @inner_labels = get_labels(\@inner_scale, $interval, $show_marks);

    my $inner_radius = $radius - $sub_radius * 3;

    $inner_style->circle(
        id => 'style-group-inner-circle',
        cx => $frame_size / 2,
        cy => $frame_size / 2,
        r  => $inner_radius,
    );

    $inner_style->text(
        id    => 'style-group-inner-info',
        x     => $frame_size / 2 - $sub_radius * 9,
        y     => $frame_size / 2,
        style => {
            stroke      => $text_line,
            'font-size' => $font_size,
        },
        -cdata => "Interval: $named{$interval}, Notes: $show_marks",
    );

    $i = 0;

    for my $mark (@marks) {
        $i++;

        my $p = coordinate(
            $mark,
            $total_marks,
            $inner_radius,
            $intervals{ $interval . ',' . $show_marks }
        );

        $inner_style->circle(
            id => $mark . '-style-group-inner-sub-circle',
            cx => $p->[0] + $sub_radius * 4,
            cy => $p->[1] + $sub_radius * 4,
            r  => $sub_radius,
        );

        my $item = $inner_labels[ $i % @inner_labels ];
        my $text = $numeric
            ? first_index { $_ eq $item } @inner_scale
            : $item;
        $inner_style->text(
            id     => $i . '-style-group-inner-sub-text',
            x      => $p->[0] + $sub_radius * 3 + 3,
            y      => $p->[1] + $sub_radius * 3 + 3 + $sub_radius,
            -cdata => $text,
        );
    }
}

print $svg->xmlify;

sub get_labels {
    my ($scale, $interval, $marks) = @_;

    my @labels = map { $scale->[ ($_ * $interval) % @$scale ] }
        0 .. $marks - 1;

    return @labels;
}

sub coordinate {
    my ($p, $total, $radius, $inner) = @_;

    # Compute the analog minute time equivalent
    my $analog = $p / $total * DOUBLE - HALF;

    # Replace the time value with the polar coordinate
    my $coord;
    if ($inner) {
        $coord = [
            $radius + $radius * cos($analog - DOUBLE / $total + $inner),
            $radius + $radius * sin($analog - DOUBLE / $total + $inner)
        ];
    }
    else {
        $coord = [
            $radius + $radius * cos($analog),
            $radius + $radius * sin($analog)
        ];
    }

    return $coord;
}
